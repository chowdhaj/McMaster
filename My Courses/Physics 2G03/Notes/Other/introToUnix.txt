Physics 2G03 - Introduction To Unix

Website: http://x86.cs.duke.edu/csl/docs/unix_course/intro-1.html#HEADING1-36

CHAPTER 1 - History of Unix

    - 1969 :: Ken Thompson, Dennis Ritchie, Rudd Canaday, and 
              Doug McIlroy designed and implemented the first 
              version of the Unix File System on a PDP-7
    - 1970 :: January 1st, 1970 is time zero for Unix
    - 1973 :: Unix is rewritten (mostly) in C; a new language 
              developed by Dennis Ritchie. This made it easier 
              to port Unix to new machines
    - 1974 :: Unix gains popularity after Thompson and Ritchie 
              publish a paper about it in the ACM
    - 1977 :: There are about 500 Unix sites world wide
    - 1984 :: There are about 100,000 Unix sites running on 
              different hardware platforms all over the world
    - 1993 :: Novell buys Unix from AT&T
    - 1995 :: Santa Cruz Op. buys UnixWare from Novell
    - 1996 :: Over 3 million Unix systems are shipped world wide

CHAPTER 2 - Unix Structure

    2.1 - The Operating System

        - Unix is a layered operating system
            - Layers: Hardware -> Kernel -> Programs
                - Hardware is the innermost layer
        - The hardware provides services for the Kernel
            - In Unix, the Kernel is referred to as the operating system
        - The Kernel interacts directly with the hardware and provides services to the user programs
            - The programs only need to communicate with the Kernel, and the Kernel will provide the requested (hardware) resources/services
        - User programs interact with the kernel through a set of system calls
            - i.e. Open, Close, Read, Write, Execute, Etc.
            - i.e. Updating account records, changing ownership of a file/directory, managining process, enabling access to hardware, setting limits of system resources, etc.
        - Unix is a multi-user, multi-tasking operating system
            - Many users can be logged into a system simultaneously, each running many programs
                - Kernel will regulate everything and efficiently allocate resources

    2.2 - The File System

        - The Unix file system looks like an inverted tree structure
            - It starts with the root directory and everything else (i.e. Files & sub-directories) are underneath and inside 'root'
                - Root directory is denoted by a forward slash ( / )
            - Each node is either a file or a directory
            - Directories can contain files and other directories
        - Example of directory path name: /home/user/bob/desktop
        - Path names can be shortened with symbols
            - i.e.
                .   -> Current directory 
                ..  -> Parent of current directory
                ~   -> Login directory
            - Above example can be shortened to:
                - ~/desktop

    2.3 - Unix Directories, Files and Inodes

        - Every directory and file is listed in its parent directory
        - The parent of the root directory is the root directory
        
        - A directory is a file that contains a table listing the files contained within it; giving file names to the 'inode' numbers in the list
        - An 'inode' is a special file designed to be read by the kernel to learn information about each file
            - Contains information like: permissions on the file, ownership, date of creation, last modified, and physical location on the storage device
        - The format and structure of the file do not matter to the 'inode' or the kernel

    2.4 - Unix Programs

        - Programs/commands interact with the kernel to perform operations called by the user
            -  A program can be:
                - Executable shell file (aka Shell Script)
                - Built in shell command
                - Compiled code
                - Object code file

        - The shell is a command line interpreter
            - The user interacts with the kernel through the shell
        
        - System programs are usually binary; compiled from C source code
            - They are located in places like:
                - /bin
                - /usr/bin
                - /usr/local/bin

CHAPTER 3 - Getting Started

    3.1 - Logging in

        - When connecting to a Unix system, the user is prompted for a username and password
            - The username is the user's unique name
            - Unix is case sensitive
        
        3.1.1 - Terminal Type
            
            - Most systems default to a terminal type prompt
            - The command `xterm` opens a terminal window
            - The terminal type indicates how to interact with the session
                - You can reset the terminal type by entering in the command: setenv TERM <term type>
                    - <term type> is the terminal type
            - The terminal only accepts 'MonoSpace' fonts

        3.1.2 - Passwords

            - The command for changing a password is `passwd`
            - Always create a strong password

        3.1.3 - Exiting

            - CTRL + D :: Indicates end of data stream, and can log a user off
            - CTRL + C :: Interrupts the program/command and force quits it
            - logout   :: Logs you out of the system; can close the terminal
            - exit     :: Exits the shell application

        3.1.4 - Identity

            - The system identifies you by the user and group numbers
                - userid
                - groupid
            - Your username is the name you login with
            - There is a group database file where the system admin can assign you rights / grant permissions

            - You can get your userid with the command `id`
            - You can see all the groups you belong to with the command `groups`

    3.2 - Unix Command Line Structure

        - A command is a program that tells the Unix system to execute a set of instructions
            - It has the form: command [options] [arguments]
                - Options change the behaviour of the command/program
                    - Multiple options can be strung together
                        - i.e. command -[option][option][option]
                            - i.e. ls -alR
                        - i.e. command -[option] -[option] -[option]
                            - i.e. ls -a -l -R
                - Arguments indicate what the command/program should perform its action(s) on (i.e. File/Directory)
            - Commands are case sensitive; `command` and `Command` are not the same
                - In general, Unix is case sensitive
            - Some commands require options/arguments
                - i.e. which [option]
                - i.e. man [option]
            - Some commands do not require options or arguments
                - i.e. whoami
                - i.e. hostname
        - Options and syntax for a command are listed in the manual pages
            - i.e. man ls
            - i.e. man id

    3.3 - Control Keys

        - Control Keys are used to perform special functions on the command line or within an editor
            - Control keys are activated by holding down CTRL and another key, at the same time
            - Control keys can be written as:
                - ^S
                - ^C
                - ^Z
            - The ^ means CTRL (control)
        - Control keys are not case sensitive
            - ^s and ^S are identical
        - Examples of Control keys
            - CTRL + S == Stop signal; tells the terminal to stop accepting input
            - CTRL + Q == Start signal
            - CTRL + U == Erases entire input line on terminal prompt

    3.4 - stty - terminal control

        - 'tty' is an abbreviation and stands for teletypewriter
        - `stty` reports or sets terminal control options; you can configure many aspects of I/O
            - i.e. Erase and line kill characters, data transmission speed, hardware flow control, interpreting tab characters, mapping of upper case to lower case, etc.
        - Examples of options for `stty`:
            -a    -> Outputs all options in `stty`
            kill  -> Set the line-kill character
            erase -> Set the erase character
            intr  -> Set the interrupt character
        - Modifying `stty` options are only in effect for the current session

    3.5 - Getting Help

        - The Unix manual (aka man pages) provide information on the usage of Unix systems and commands
        - To view a manual page, type `man` followed by a command
            - i.e. man ls
            - i.e. man passwd
        - Syntax for `man`
            man [options] commandName
        - Example use:
            - man -k password
                - This will search the synopsis of every man page and find the word 'password'
            - Sample output of `man -k password`:
                kpasswd(1)   -   Kerberos 5 password changing program
                    - 'kpasswd' is the name of the command
                    - (1) is the section where 'password' occurs
                    - Everything after the hyphen is the sentence where 'password' is located

    3.6 - Directory Navigation and Control

        - The Unix file system is set up like an inverted tree. The stem is the root directory and the branches are sub-directories
        - The root directory is symbolized by a forward slash: /
        - System files and user directories are all under root
        - The user does not have a root directory
            - Instead, users log into their own home directory

        - Summary of important commands for managing directories:

            cd [directoryName]
                - Change directory to [directoryName]
            ls [options] [directoryName / fileName]
                - List [directoryName]'s contents or [fileName]'s permissions
                    - [options] is used to modify the default behaviour of `ls`
            mkdir [options] [name]
                - Make a directory called [name]
            pwd
                - Print working (current) directory
            rmdir [options] [directoryName]
                - Remove the the directory called [directoryName]
        - Note: Anything is [square brackets] is an arbitrary option

        3.6.1 - pwd - print working directory

            - The `pwd` command outputs where you are in the file system hierarchy
                - It outputs the full path, starting from the home directory

        3.6.2 - cd - change directory

            - The `cd` command allows you to change directories
            - It accepts both absolute and relative path names

            - Syntax: cd [directory]
                cd 
                    - Change to user's home directory
                cd ~
                    - Change to user's home directory
                cd /
                    - Change to root directory
                cd ..
                    - Goes back one directory
                cd ../..
                    - Goes back two directories
                cd ~/users/bob/Desktop/games
                    - Change to 'games' directory on 'Desktop'

        3.6.3 - mkdir - make a directory

            - Allows you to make empty directories

            - Syntax: mkdir [options] [nameOfDirectory]
                mkdir testDir
                    - Creates empty directory called 'testDir'
                mkdir user/bob/files
                    - Creates an empty directory called 'files' inside 'bob'. The directories 'user' and 'bob' must already exist for this to work
                mkdir -p test/top/mid/bottom
                    - Creates a series of empty directories. The first directory is 'test'. Inside test is 'top', inside 'top' is 'mid', and inside 'mid' is 'bottom'. All directories are empty

        3.6.4 - rmdir - remove directory

            - Before you delete a directory, it must be empty
                - You must remove all files inside the directory first
            - You cannot remove your present working directory
                - You must switch to a parent directory and then you can remove it
                    - You cannot switch to a sub-directory

            - Syntax
                rmdir [directoryName]
                    - Remove empty directory called [directoryName]

        3.6.5 - ls - list directory contents

            - List all files and directories inside a directory
            - Can output information like size, type of file, permissions, creation date, modification date, etc.

            - Syntax: ls [options] [arguments]
                ls -a
                    - List all files, including hidden files, of current directory
                ls -d
                    - List all sub-directories, not files, in current directory
                ls -l [directoryName]
                    - List all files and sub-directories of [directoryName] in a long list with extra information about each file
                ls -la [directoryName]
                    - List all, hidden, files and sub-directories of [directoryName] in a long list format

            - File access permissions:
                r -> read permission
                w -> write permission
                x -> Execute permission
                ~ -> permission

                d -> File is a directory

    3.7 - File Maintenance Commands

        - The following is a summary of commands that allow you to create, copy, remove, and change permissions of files:
            
            chgrp [options] [groupFile]
                - Change the group of a file
            chmod [options] [fileName]
                - Change file RWX permissions or directory access permissions
            chown [options] [fileName]
                - Change ownership of a file
                    - Can only be done by superuser
            cp [options] [file1] [file2]
                - Copy [file1] into [file2]
                    - [file2] should not exist or else it will get overwritten
            mv [options] [file1] [file2]
                - Move [file1] into [file2]
            rm [options] [fileName]
                - Delete a file or directory

        3.7.1 - cp - copy a file

            - Copy the contents of one file to another with the `cp` command

            - Syntax: cp [options] [fileName] [newFileName]
                cp -i [fileName] [newFileName]
                    - Asks for confirmation before proceeding
                cp -r [directoryName] [newDirectoryName]
                    - Recursively copy a directory and its contents
                    - Outputs two identical directories that are independent of each other. Each directory has its own inode, data blocks, and directory table entries

        3.7.2 - mv - move a file

            - Move file or directory from one directory to another
              OR
            - Rename file or directory

            - Syntax: mv [options] [fileName] [newFileName]
                mv test1.txt test2.txt
                    - Renames file 'test1.txt' to 'test2.txt'
                mv games/ movies/
                    - Renames directory 'games' to 'movies'
                mv code.py python/code.py
                    - Moves the file 'code.py' into the 'python' directory. The name of the file remains untouched
                mv sixnine/ allSongs/sixnine
                    - Moves the directory 'sixnine' to the 'allSongs' directory
                        - Even if there are files in 'sixnine' the recursive flag is not needed
            - Some flags for `mv`:
                mv -i [file1] [file2]
                    - The `-i` flag asks for confirmation before executing the `mv` command
                mv -f [file1] [file2]
                    - The `-f` flag does not prompt or ask for confirmation; it overwrites existing target file(s), if any

            - When you move files or directories, all you are doing is updating the directory table with the new location; the contents of the file or directory remain untouched
                - Holds true for renaming files. The directory table is updated with the new name

        3.7.3 - rm - remove a file

            - The `rm` command removes a file(s)
                - The `rm' command cannot remove directories without flag(s)
                    - Use `rmdir` to remove EMPTY directories
            - Syntax: rm [options] [fileName]
                rm code.hs
                    - Removes the file 'code.hs'
                rm test1.txt test2.txt test3.txt
                    - Removes the files: 'test1.txt', 'test2.txt', and 'test3.txt'
            - Some flags for `rm`: 
                rm -i code.hs
                    - The `-i` flag asks for confirmation before deleting file(s)
                rm -r songs/
                    - The `-r` flag recursively deletes the 'songs' directory by removing the files and sub-directories inside
                        - `rm -r` can also be used to delete an empty directory
                rm -f code.hs
                    - The `-f` flag removes the file without prompting for confirmation

            - Removing a file or directory does not actually delete it. Instead, it updates the directory table and marks the inode as unused
                - The files are still on the disk, but the system has no way of identifying those data blocks with a file name

        3.7.4 - File Permissions

            - Each file, directory, and executable has permissions set for who can read, write, and/or execute it
                - The command `ls -l` shows (RWX) permissions assigned to a file
                    - `ls -lg` shows which group the permissions are set
            - The `ls -lg` command will output in a format similar to:
                drwxr-x--- user unixgroup size Month nn hh:mm directoryName
                -rwxr-x--- user unixgroup size Month nn hh:mm filename

                - The file 'fileName' has the following permissions:
                    -rwxr-x---
                        - The owner has full read, write, and execute permission over 'fileName'
                        - Unixgroup can read and execute 'fileName'
                        - Others cannot access 'fileName' at all

        3.7.5 - chmod - change file permissions

            - The `chmod` command changes permissions on a file or directory
                - `chmod` is short for change mode
            - The user/owner is represented by 'u'
            - Group is represented by 'g'
            - Other is represented by 'o'

            - Each permission type is represented by a numeric equivalent or single letter
                - Numeric:  
                    4 == read permission
                    2 == write permission
                    1 == execute permission
                    0 == no permissions
                - Single Letter: 
                    r == read permission
                    w == write permission
                    x == execute permission
            - A permission setting of 6 allows for read and write permissions because read is 4 and write is 2; the sum is 6. A permission setting of 7 gives full access to rwx; because 4 + 2 + 1 = 7
                - Each number represents who the permissions apply to
                    - For example: 771 means that 'user' has full rwx, 'group' has full rwx, and 'other' only has execution privilegies
                    - For example: 531 means that 'user' can read and execute, 'group' can write and execute, and 'other' can only execute
            - Another way to set permissions is with symbolic notation. The operators are:
                +  -> Add specified permissions
                -  -> Remove specified permissions
                =  -> Changes current permissions to the 
                      specified permissions

                - For example: 'u=rw' means that 'user' can read and write
                - For example: 'o-wx' means that write and execute permissions have been removed from 'other'
                - For example: 'g+rx' means that 'group' has gained the permissions read and execute

            - Syntax:
                - Numeric mode: chmod nnn [arguments]
                    - nnn       == Three numbers representing user,
                                   group, and other permissions
                    - arguments == The file(s) that need permission changing

                - Symbolic mode: chmod [who][op][perm] [arguments]
                    - [who]  == Any one or combination of {u, g, o}
                        - Can also use 'a' for all
                    - [op]   == Symbolic notation: {+, -, =}
                    - [perm] == Permission: Combination of {r, w, x}

                - See 'Examples' (below) for more.

            - Some flags for `chmod`:
                chmod -f 774 main.java
                    - The `-f` flag forces permission change; no error message generated if change is unsuccessful
                chmod -R 777 dirName/
                    - The `-R` flag recursively descends through directory structure and changes the permission for all files and sub-directories

            - Examples:
                - Change permission of 'file1' so that user has rwx, group has re, and other has re
                    - Numeric mode: chmod 755 file1
                    - Symbolic notation: chmod u=rwx,go=rx file1
                - Change permission of 'file2' so that user has rwx, group and other have x
                    - Numerc mode: chmod 711 file2
                    - Symbolic notation: chmod u=rwx,go=x file2

            - In order to access a directory, you need to have execute permissions in order to be able to access the directory

        3.7.6 - chown - change ownership

            - Ownership of a file can be changed with the `chown` command
                - Only be done by the super-user

            - Syntax: chown [options] user[:group] fileName
                - i.e. chown user sampleFile.txt
            
            - Some flags for `chown`:
                chown -R userName dirName/
                    - The `-R` flag recursively descends through the directory and changes ownership of all files and sub-directories
                chown -f userName testFile.txt
                    - The `-f` flag forces an ownership change and does not report errors

        3.7.7 - chgrp - change group

            - Anyone can change the group of files they own, to another group they belong to, with the `chgrp` command

            - Syntax: chgrp [options] group fileName
                - i.e. chgrp user testFile.txt

            - Some flags for `chgrp`:
                chgrp -R groupName dirName/
                    - The `-R` flag recursively descends through the directory and changes every file and sub-directory
                chgrp -f groupName dirName/
                    - The `-f` flag forces a group change and does not report errors

    3.8 - Display Commands

        - The following is a summary of commands that can be used to display or view files:

            - cat [options] [fileName]
                - Outputs content of [fileName] to terminal
                    - Outputs entire file
            - echo [text]
                - Echoes (outputs) the [text] to the screen/terminal
            - head -[n] [fileName]
                - Outputs the first 'n' number of lines from [fileName]
            - tail -[n] [fileName]
                - Outputs the last 'n' number of lines from [fileName]
            - more [options] [fileName]
                - Outputs content of [fileName] to screen, one page at a time
            - less [options] [fileName]
                - Outputs content of [fileName] to screen and you can scroll forwards and backwards through the output
                    - Similar to `more` but smarter and more functional

        3.8.1 - echo - echo a statement

            - The `echo` command is used to repeat the argument you give it, back to the terminal or output device
            
            - Syntax: echo [text]
                - echo Output this to terminal
                - echo This command is like a parrot

            - Some flags for `echo`:
                echo -n Hello World
                    - The `-n` flag does not add a newline (\n) at the end of the output

        3.8.2 - cat - concatenate a file

            - The `cat` command displays the contents of a file

            - Syntax for `cat`: cat [options] [file]
                cat test1.txt
                cat notes1.txt notes2.txt
                    - You can view multiple files, one after another

            - Some flags for `cat`: 
                cat -n main.cpp
                    - The `-n` flag adds the corresponding line number before each line. This is good for source code because it tells you exactly what line a particular line of code is on
                cat -v file.txt
                    - The `-v` flag displays non-printing characters, except for tabs, newlines, form-feeds, etc.
                cat -e 
                    - The `-e` flag puts a '$' at the end of each line. This is good if you want to know where a line ends and another one starts; very useful when working in a tiny terminal window

        3.8.3 - more, less, and pg - page through a file

            - The commands `more`, `less`, and `pg` let you page through the contents of a file one screenful at a time.
                - The `pg` command might not be available on your system
                    - The `pg` command is not discussed below
                - You can even search for words
         
            - Syntax for `more`: more [options] [fileName]
                more instructions.txt
                more intro1.txt intro2.txt
                    - You can give the command `more` multiple file names and it will sequentially display them    
                        - Press <SPACE> to display next file                

            - Syntax for `less`: less [options] [fileName]
                less bigManual.txt
                less part1.txt part2.txt
                    - The command `less` can accept multiple files and will display them one at a time in order
                        - Type ':n' to go to next file and ':p' to go to previous file

            - Some flags for `more` and `less`:
                more -p someText bigFile.txt
                less -p someText bigFile.txt
                    - The `-p` flag searches for [someText] in [bigFile.txt]. It is identical to 'find text' and pressing (CTRL + F)
                more -c code.py
                less -c code.py
                    - The `-c` command clears the terminal window/display before outputting the contents of [code.py]
                more -i roughNotes.txt
                less -i roughNotes.txt
                    - The `-i` command ignores case when searching for patterns. So, the words 'cat' and 'CAT' are the same
                more -N main.java
                less -N main.java
                    - The `-N` flag displays the line number on the left side. This is useful when finding syntax errors in your code 

        3.8.4 - head - display the start of a file

            - The `head` command displays the start of the file; the first 10 lines
                - Essentially it is like peaking a file without opening it
                - Great for files with lots of lines

            - Syntax for `head`: head [options] [fileName]
                head longFile.txt
                head hugeEssay.txt
                head roughNotes1.txt roughNotes2.txt
                    - You can peak multiple files at once with `head`

            - Some flags for `head`:
                head -n 30 longFile.txt
                    - The `-n` flag displays the first 'n' number of lines of [longFile.txt]
                head -30 roughNotes.txt
                    - You can skip writing 'n' and just put a number next to the minus and this will also work

        3.8.5 - tail - display the end of a file

            - The `tail` command displays the end of a file; the last 10 lines

            - Syntax for `tail`: tail [options] [fileName]
                tail longFile.txt
                tail hugeEssay.txt
                tail roughNotes1.txt roughNotes2.txt
                    - You can see the end of multiple files at once with `tail`

            - Some flags for `tail`: 
                tail -n 30 longFile.txt
                    - The `-n` flag displays the last 'n' number of lines of [longFile.txt]
                tail -30 roughNotes.txt
                    - You can skip writing 'n' and just put a number next to the minus

CHAPTER 4 - System Resources & Printing

    4.1 - System Resources

        - The following is a summary of commands that are used to report or manage system resources:

            - chsh [options] [LOGIN]
                - Changes the user's shell 
                    - Examples of shells: tcsh, bash, zsh, fsh, csh, etc.
            - date [options]
                - Outputs the current date and time
            - df [options] [resource]
                - Outputs the summary of disk blocks and inodes that are free or in-use
            - du [options] [directory OR file]
                - Outputs amount of disk space used
            - hostname [options]
                - Display or set the name of the current machine
            - uname [options]
                - Print operating system name
            - kill [options] [argument]
                - Terminate a signal or process/program
            - man [options] [command]
                - Show the manual pages for [command]
            - passwd [options] 
                - Set or change your password
            - ps [options]
                - Show status of active processes
            - script file
                - Saves everything that appears on screen to [file] until `exit` is executed
                    - Essentially, this acts as a recorder for everything inputted into or outputted by the terminal
            - stty [options] 
                - Set or display terminal control options
            - whereis [options] [command]
                - Report the binary, source, and man page locations for [command]
            - which [command]
                - Reports the path where [command] executable is located
            - who
                - Reports who is logged in and what processes are running
                    - Can also use `w` as a substitute for `who`

        4.1.1 - df - summarize disk block and file usage

            - The command `df` reports the number of disk blocks and inodes that are used and free for each file system
                - Essentially, `df` displays free disk space

            - Syntax: df [options] [resource]
                df
                    - It's that simple. Just type `df` and press <ENTER>

            - Some flags for `df`:
                df
                    - No arguments/options needed
                df -k
                    - Reports the space in kilobytes
                df -l 
                    - Reports local file systems only
                df -h
                    - Outputs the result in a human readable format

        4.1.2 - du - report disk space in use

            - The command `du` reports disk usage for the files or directories you specify

            - Syntax: du [options] [directory OR file]
                du bigMovie.mp4
                du gamesFolder/
                du file1.txt file2.txt
                    - Multiple files can be checked at once

            - Some flags for `du`:
                du -a
                    - Displays disk usage for each file in the directory, and not just the directory
                du -s
                    - Outputs only a summary of the total
                du -h
                    - Displays result in a human readable format

        4.1.3 - ps - show status of active processes

            - The command `ps` is used to output process currently running on the system
                - The functionality of `ps` is dependent on the operating system

            - Syntax for `ps`:
                ps [options]
                    ps
                        Lists all processes with controlling terminals. No argument/option needed
                    ps -a
                        - Reports all processes from all users
                    ps -e
                        - Reports all processes from all users, including those without controlling terminals
                    ps -l
                        - Outputs in a long format
                    ps -x
                        - Reports proceses not executed from terminals

        4.1.4 - kill - terminate a process

            - The command `kill` sends a signal to a process, usually to terminate it
                - Type in `kill -l` for a list of all available signals

            - Syntax for `kill`: kill [signal] [process]
                kill -9 737
                    - Kills the program with the PID 737
                kill -9 2245
                    - Kills the program with the PID 2245
                kill 2100
                    - This command has no signal as an argument because a signal is optionable
                        - It is recommended to use signals

            - Note: Do not kill random processes, it will cause trouble

        4.1.5 - who - list current users

            - The command `who` reports all users that are logged in

            - Syntax for `who`: who [options]
                who
                    - Lists everyone who is logged in. No arguments needed.
                who -b
                    - Outputs time of last reboot; last time the machine was restarted
                who -d
                    - Prints dead processes
                who -m
                    - Prints information about current terminal
                who -u
                    - Prints idle time for each user

        4.1.6 - whereis - report program locations

            - The command `whereis` returns the location of source, binary, and manual page files associated with a command; command is the argument
                - Works on select systems; does not work on OS X

            - Syntax for `whereis`: whereis [options] [command]
                whereis cd
                    - Outputs location information for `cd`
                whereis man
                whereis ls

            - Some flags for `whereis`:  
                whereis -b cd
                    - Only reports binary file(s)
                whereis -m man
                    - Only reports manual page file(s)
                whereis -s ls
                    - Only reports source file(s)

        4.1.7 - which - report the command found

            - The command `which` reports the location of the commands executable file. In the other words, the program that is executed when you hit enter to execute a command
                - The location returned is the full path

            - Syntax for `where`: which [options] [command]
                which cd
                    - Outputs the full path of where the executable for `cd` is located
                which ls
                which man

            - Some flags for `which`: 
                which -a ls
                    - Lists all instances of executables found, not just the first one
                which -s man
                    - Changes the output to 0 if executable(s) are found, or 1 if no executable was found

        4.1.8 - hostname/uname - name of machine

            - The command `hostname` reports the name of the current host system

            - Syntax for `hostname`: hostname [options]
                hostname
                    - Outputs host name. No options required
                hostname -f
                    - Functions same as `hostname` without arguments
                hostname -s
                    - Trims off domain name information

            - The command `uname` prints Operating System name
                - With the right arguments `uname` can output other important information (i.e. Hardware name, architecture, etc.)

            - Syntax for `uname`: uname [options]
                uname
                    - Prints operating system name
                    - Output is identical to `uname -s`

            - Some flags for `uname`:
                uname -a
                    - Behaves as if all options were specified; uname -mnrsv
                uname -m
                    - Prints machine hardware name
                uname -n
                    - Prints the nodename; the name that the system is known by to a communications network
                    - Output is identical to the command `hostname`
                uname -p
                    - Prints the machine processor architecture
                uname -r
                    - Prints the operating system release
                uname -s
                    - Output is identical to `uname` without options/arguments
                uname -v
                    - Prints the operating system version

        4.1.9 - script - record your screen I/O

            - The command `script` logs all data transmission to and from the terminal screen until you `exit` the script program
                - In other words, everything you type into the terminal and all output you get from the terminal is saved into a file
                    - To quit, type 'exit' and press <ENTER>
                - Very useful for debugging

            - Syntax for `script`: script [options] [fileName]
                script
                    - Logs terminal session input/output and saves it to a file called 'typescript'
                script file
                    - Save terminal session input/output to [file]
                script terminalHistory.txt
                    - Saves terminal session IO to [terminalHistory.txt]

            - Some flags for `script`:
                script -a [fileName]
                    - Appends output to [fileName]; does not delete content already present in [fileName]
                script -F [fileName]
                    - Immediately update [fileName] after each write. Useful if someone else wants to watch you use a terminal live using the `cat` command
                script -q [fileName]
                    - Run in quiet mode; omit the start and stop messages
                script -t [fileName]
                    - Set the interval, in seconds, at which [fileName] will be updated with recent IO log

        4.1.10 - date - current date and time 

            - The `date` command displays the current date and time
                - A superuser can set the date and time

            - Syntax for `date`: date [options] +[format]
                date
                    - Outputs date and time in the following format:
                        Weekday Day Month Year Time Timezone
                            - (i.e. Wed 30 Sep 2020 19:20:10 EDT)
                date +%H:%M:%S
                    - Prints the time in the format HH:MM:SS
                        - (i.e. 19:35:09)
                date +Day\ Of\ Year\:\ %j%nMonth\:\ %h
                    - Prints the day of year and month
                        - (i.e. date +Today\'s\ Date\:\ %a,\ %h\ %d,\ %Y)

            - Some formatting options:
                %a -> Weekday abbreviation (i.e. Sun - Sat)
                %h -> Month abbreviation (i.e. Jan - Dec)
                %d -> Day of month (i.e. 0 - 28, 29, 30, 31)
                %Y -> Full year (i.e. 1968)
                %y -> Last 2 digits of year (i.e. 00 - 99)
                %j -> Day of year (i.e. 001 - 366)
                %n -> newline (\n)
                %t -> <TAB>
                %D -> Date in the format: MM/DD/YY
                %H -> Hour (i.e. 00 to 23)
                %M -> Minute (i.e. 00 to 59)
                %S -> Seconds (i.e. 00 to 59)
                %T -> Time in the format: HH:MM:SS

            - Some flags for `date`:    
                date -r 50
                    - Print the date and time since 50 seconds past Epoch
                date -u
                    - Display date in UTC time
                date -v +[val]
                    - Subtract current date from [val]
                        - [val] is a formatted date that the `date` commmand can read
                            - See above for formatting options
                    - i.e.:
                        date -v1d -v+1m -v-1d -v-fri
                            - Displays last friday

    4.2 - Print Commands

        - Print commands allow us to print files to standard output (`pr`) or to a line printer (`lp`, `lpr`), while filtering the output. The following is a summary of printing commands:

            - lpq [options]
                - Shows the status of print jobs
            - lpr [options] [file]
                - Prints [file] to a defined printer
            - lprm [options] 
                - Removes a print job from the print queue
            - pr [options] [file]
                - Filter the file and print it on the terminal

        4.2.1 - lp/lpr - submit a print job

            - The commands `lp` and `lpr` submit a file, or standard output, to a printer daemon to be printed. 
                - Each job is given a unique request ID so that it can be tracked or cancelled while the job is in queue
                - Note: 
                    - TXT files are supported
                    - PDF files are supported
                    - Microsoft Word files are not supported
                        - Any MS Suite program is not supported

            - Syntax for `lp`: lp [options] [filename]
                lp unix.txt
                    - Prints the text file 'unix.txt' to the default printer using default settings
                lp phoneManual.pdf
                    - Prints the file 'phoneManual.pdf' to the default printer using default settings
            - Syntax for `lpr`: lpr [options] [filename]
                lpr unix.txt
                    - Same as `lp`
                lpr phoneManual.pdf
                    - Same as `lpr`

            - Some flags for `lp` and `lpr`:
                lp -E [fileName]
                lpr -E [fileName]
                    - The `-E` flag forces encryption when connecting to the server
                lp -U [userName]
                lpr -U [userName]
                    - The `-U` flag specifies an alternate username for the printing job
                lp -m [fileName]
                lpr -m [fileName]
                    - The `-m` flag sends an email once the printing job has completed
                
                lp -H [option] [fileName]
                    - The `-H` flag specifies when the job should be printed. For example:
                        lp -H immediate [fileName]
                            - This prints the file immediately
                        lp -H hold [fileName]
                            - This holds the printing job indefinitely
                        lp -H resume [fileName]
                            - Resumes the printing job that was previously put on hold
                lp -n 3 [fileName]
                    - Prints 3 copies of [fileName]
                
                lpr -# 6 [fileName]
                    - Prints 6 copies of [fileName]
                lpr -q [fileName]
                    - Holds the job for printing

        4.2.2 - lpstat/lpq - check the status of a print job

            - The commands `lpstat` and `lpq` check the status of the printing job

            - Syntax for `lpstat`: lpstat [options]
                lpstat
                    - Lists active printing jobs queued by current user
                lpstat -r
                    - Shows whether the CUPS server is running
            - Syntax for `lpq`: lpq [options] [job#] [username]
                lpq
                    - Shows jobs queued on the default destination/printer
                    - Can be used to show default destination/printer
                lpq -a
                    - Reports all jobs on all printers
                lpq 104
                    - Shows information on printing job ID 104
                lpq JimBob
                    - Shows printing information pertaining to the user 'JimBob'. For example:
                        - Default destination/printer for 'JimBob'
                        - Active print jobs for 'JimBob'

            - Some flags for `lpstat` and `lpq`:
                lpstat -E
                lpq -E
                    - The `-E` flag forces encrpytion when connecting to server
                lpstat -U [userName]
                lpq -U [userName]
                    - The `-U` flag shows printing (job) information pertaining to [userName]

                lpstat -R
                    - Shows the ranking of print jobs
                lpstat -r
                    - Shows whether the CUPS server is running
                lpstat -d
                    - Shows the current default destination
                lpstat -l
                    - Shows a long list of printers, classes, or jobs
                lpstat -t
                    - Shows ALL status information
                        - Equivalent to running `lpstat -vaocrd`

                lpq -a
                    - The flag `-a` reports all printing jobs on all printers
                lpq -l
                    - Shows information in a long (verbose) format

        4.2.3 - cancel/lprm - cancel a print job

            - The `cancel` and `lprm` commands allow users to cancel print jobs

            - Syntax for `cancel`: cancel [options]
                cancel
                    - Cancels the current printing job on the default destination/printer
                cancel 103
                    - Cancels the printing job ID 103 on the default printer
                cancel -x
                    - Deletes the printing job's data files in addition to cancelling
            - Syntax for `lprm`: lprm [options]
                lprm
                    - Cancels the current printing job on the default destination/printer
                        - Functions identical to `cancel`
                lprm 103
                    - Cancels the printing job ID 103 on the default printer

            - Some flags for `cancel` and `lprm`:
                cancel -E
                lprm -E
                    - The `-E` flag forces encrpytion when connecting
                cancel -U JimBob
                lprm -U JimBob
                    - The `-U` flag cancels the printing job of JimBob

                cancel -a
                    - Cancels all jobs on all destinations/printers or a specific destination/printer if provided
                cancel -x
                    - Deletes all data files in addition to cancelling

                lprm -
                    - Cancels all jobs on the default printer

        4.2.4 - pr - prepare files for printing

            - The `pr` command prints header, trailer, and pagination information for a file. The output is formatted and divded into pages
                - By default, one page is 66 lines
                - Only works on TXT files

            - Syntax for `pr`: pr [options] [fileName]
                pr lectureNotes.txt
                    - Prints the file [lectureNotes.txt] to console
                pr unix.txt
                    - Prints the file [unix.txt] to console

            - Some flags for `pr`:
                pr +2 unix.txt
                    - Begin printing at page #2 of [unix.txt]
                pr -3 unix.txt
                    - Divides the output into 3 columns and then prints it
                pr -h Linux unix.txt
                    - Uses the word 'Linux' to replace the file name in the header line
                pr -l 100 unix.txt
                    - Prints 100 lines on each page, instead of the default 66
                pr -o 5 longBook.txt
                    - Each line of output is preceded by 5 spaces
                print -t classNotes.txt
                    - The `-t` flag does not print header information, and it doesn't divide the output into pages
                        - Output is similar to `cat classNotes.txt`

CHAPTER 5 - Shells

    - The shell is a command interpreter. It acts as the middleman between the user and the operating system. It reads terminal input, and translates the commands into actions which the system undertake. 
        - When the shell starts up, it reads startup files and (may) set environment variables, command search paths, aliases, and other commands specified in configuration files.
    - The original shell was the Bourne Shell, 'sh'
        - Every Unix platform will either have a Bourne Shell, or a Bourne compatible shell
            - The Bourne Shell is good for controlling input and output, but not suited for interaction
    - The C shell, 'csh', is found on most Unix platforms
        - It uses C type syntax
            - Note: Unix is written in C 
        - C shell has job control, which is used to reattach a job running in the background to the foreground
        - C shell provides a history feature which allows you to modify and repeat previously executed commands
    - The default prompt for the Bourne shell is: $
        - For root users, the prompt is: #
    - The default prompt for the C Shell is: %
    - There are many different kinds of shells, such as:
        - Korn shell (ksh)
            - Developed by David Korn
            - Based on 'sh'
        - Bourne Again Shell (bash)
            - Developed by the Free Software Foundations GNU Project
            - Based on 'sh'
        - T-C shell (tcsh)
            - Based on 'csh'
        - Extended C shell (cshe)
            - Based on 'csh'
    - Almost all shells are based on 'sh' or 'csh', and have similar extensions such as:
        - Job control
        - Inline editing of commands
        - Page through previously executed commands
        - Tab completion of commands
        - Custom prompt
        - Etc.

    5.1 - Built-in Commands

        - Shells have built-in or native commands
            - These are executed directly in the shell, and don't rely on other programs
                - Built in commands are different for the 'sh' shell and 'csh' shell

        5.1.1 - Sh

            - Here are some commonly used built-in commands:
                - :
                    - The colon ( : ) is the null command 
                - . 
                    - The dot ( . ) is identical to the `source` command, it reads and executes commands from a file. When setting an alias, you need to `source` the file

                - `case`   : case conditional loop
                - `cd`     : change the working directory
                - `echo`   : write a string to standard output
                - `eval`   : evalute the given arguments and feed the result back to the shell
                - `exec`   : execute the given command, replace the current shell
                - `exit`   : exit the current shell
                - `export` : share the specified environment variable with subsequent shells
                - `for`    : conditional for loop
                - `if`     : conditional if statement
                - `pwd`    : print current working directory
                - `read`   : read a line of input from stdin
                - `set`    : set variables for the shell
                - `test`   : evaluate an expression as true or false
                - `trap`   : trap for a typed signal and execute commands
                - `umask` : set a default file permission mask for new files
                - `unset`  : unset shell variables
                - `wait`   : wait for a specified process to terminate
                - `while`  : conditional while loop

        5.1.2 - Csh

            - The C shells commonly used built-in functions are:
                - `alias`    : assign a name to a function 
                - `bg`       : put a job in the background
                - `cd`       : change the current working directory
                - `echo`     : write a string to stdout
                - `eval`     : evalute the given arguments and feed the result back to the shell
                - `exec`     : execute the given command, replacing the current shell
                - `exit`     : exit the current shell
                - `fg`       : bring a job to the foreground
                - `foreach`  : conditional for loop
                - `glob`     : filename expansion on a list, but no '\' escapes are honored
                - `history`  : print the command history of the shell
                - `if`       : conditional if-statement
                - `jobs`     : list or control active jobs
                - `kill`     : kill the specified process
                - `limit`    : set limits on system resources
                - `logout`   : terminate the logout shell
                - `nice`     : lower the scheduling priority of a process 
                               (i.e. nice [command])
                - `nohup`    : do not terminate the command when the shell exits 
                               (i.e. nohup [command])
                - `popd`     : pop the directory stack and return to that directory
                - `pushd`    : change to the new directory specified and add the current 
                               one to the directory stack
                - `rehash`   : recreate the hash table of paths to executable files
                - `repeat`   : repeat a command the specified number of times
                - `set`      : set a shell variable
                - `setenv`   : set an environment variable for current and subsequent shells
                - `source`   : read and execute commands from a file
                               (Must be used when adding a new alias)
                - `stop`     : stop the specified background job
                - `switch`   : conditional switch statement(s)
                - `umask`   : set a default file permission mask for new files
                - `unalias`  : remove the specified alias name
                - `unset`    : unset shell variables
                - `unsetenv` : unset shell environment variables
                - `wait`     : wait for all background processes to terminate
                - `while`    : conditional while loop

    5.2 - Environment Variables

        - Environmental variables are used to provide information to the programs you use
            - Variables are either global or local
                - Global environment variables are set by your login shell
                    - New programs and shells inherit the environment of their parent shell
                - Local variables are set in the current active shell
                    - Only used by current (active) shell and not passed on to other processes
        - A child process (shell) cannot pass a variable back to its parent process/shell

        - Environment variables can be displayed with the commands `env` and `printenv`
            - Some common variables are:

                - DISPLAY : The graphical display to use (i.e. nyssa:0.0)
                - EDITOR  : The path to your default editor (i.e. /usr/bin/nano)
                - GROUP   : Your login group (i.e. Staff)
                - HOME    : Path to your home directory (i.e. /home/Jim)
                - HOST    : The hostname of your system (i.e. nyssa)
                - IFS     : Internal field separator, usually any white space
                            (Defaults to <TAB>, <SPACE>, and <newline>)
                - LOGNAME : The name you login with (i.e. Jim)
                - PATH    : Specifies the directories to be automatically searched
                            for, for the command (i.e. `cd`, `ls`, etc.) you type. This 
                            is how the shell can auto-complete commands for you. It 
                            searches this path and finds matching commands
                            (i.e. /usr/bin:/usr/ucb:/usr/local/bin)
                - PS1     : The primary prompt string (Defaults to '$')
                - PS2     : The secondary prompt string (Defaults to '>')
                - SHELL   : The login shell you are using (i.e. /usr/bin/csh)
                - TERM    : Your terminal type (i.e. xterm)
                - USER    : Your username (i.e. John)

        - Many environment variables will be automatically set when you login
            - They can be changed by modifying the startup files or specifying within the shell

        - Setting environment variable(s)
            - C Shell: setenv [NAME] [value]
                - `NAME` is the variable you want to change (i.e. Display, Editor, etc.)
                - `value` is what you want to change it to
            - Bourne Shell: NAME=value; export NAME
                - `NAME` and `value` have identical definitions to the above ones

        - Global environment variables can be listed with `env` or `printenv`
            - They can be unset with the `unsetenv` and `unset` commands
                - Note: `unsetenv` is for C Shell, and `unset` is for Bourne Shell

        - The `set` can be used to set a local shell variable. For example: 
            - C Shell: 
                set name=value
            - Bourne Shell: 
                name=value

        - The command `set` can be used to list all local Variables
            - Type in `set` in the terminal without the quotes and press enter
        - The current value of the variable can be accessed via the following notations:
            $NAME
                - i.e. echo $PS1
            ${NAME}
                - i.e. echo ${PS1}

    5.3 - The Bourne Shell, sh

        - The Bourne shell (sh) executes the file '.profile' in your home directory
            - This file is a startup file and is executed when you open a shell
            - If there is a system-wide start up file, then 'sh' will execute it before the local one

        - A basic '.profile' file could be:
            
            -------------------------------------------
            | PATH=/usr/bin:/usr/ucb:/usr/local/bin:. |
            | export PATH                             |
            -------------------------------------------

            - The first line sets the PATH variable
                - Everything after the equals ( = ) sign is the value
            - The second line makes the PATH variable availab to subshells
            - Each directory is separated with a colon ( : )
            - ( :. ) tells shell to search your CURRENT directory

        - You can a prompt like this:
            PS1="{`hostname` `whoami`} "
                    OR
            PS1="\h:\W \u\$ "

        - You can set the terminal type (i.e. Modify keyboard shortcuts) like this:
            stty werase ^W
                Sets {Control + W} to erase one word at a time

        - The hashtag ( # ) symbol is used to comment a line

        - A variable set in '.profile' is set only in the login shell unless it is exported or 'source' from another shell

    5.4 - The C Shell, csh

        - The startup files for C shell are '.cshrc' and '.login'
            - '.login' is executed only when you login
            - 'cshrc' is executed every time a new shell is started, including when you login
                - Similar to '.profile' in Bourne shell
        - The commands `set` and `setenv` are used to initialize environment variables
            - `set` is used for the current shell
            - `setenv` is used for the current shell and all subshells
        - C shell uses the tilde ( ~ ) to denote the user's home directory
            /user/Jim/Desktop

        - Some predefined variables used by C Shell:
            - argv      : The list of arguments of the current shell
            - cwd       : The current working directory
            - history   : Sets the size of the history list to save
            - home      : The home directory of the user; starts with $HOME
            - ignoreeof : When set, ignore EOF (^D) from terminals
            - noclobber : When set, prevent output redirection (i.e. ls > file.txt)
                          from overwriting existing files
            - noglob    : When set, prevent filename expansion with wildcard 
                          pattern matching
            - path      : The command search path; starts with $PATH
            - prompt    : Set the command line prompt (default is %)
            - savehist  : Specify number of lines to save in the history list, to
                          save in the '.history' file
            - shell     : The full pathname of the current shell; starts with $SHELL
            - status    : The exit status of the last command
                          (0 = Normal Exit; No Error(s))
                          (1 = Command Failed; Error(s) Present)
            - term      : The terminal type; starts with $TERM
            - user      : Your username; starts with $USER

        - `alias` is used to shorten commands
            - i.e. alias h history
                - Typing 'h' will act as 'history'

        - After making any change to the startup file(s), '.login', '.cshrc', etc., you should source the changes. This tells the shell to execute the commands inside the file
            - i.e. source ~/.cshrc

        - More information about shells can be obtained from the manual pages
            - i.e. At the terminal type:
                man csh
                man bash

    5.5 - Job Control

        - You can put jobs into the background at any time by appending '&' to the command. 
            - Alternatively, after entering a command, hit {Control + Z} to suspend the job and then type 'bg' to background the program. 
            - 'fg' will bring a process back to the foreground
        - You can have many jobs running in the background
            - When jobs are in the background, they are no longer connected to the keyboard for input
                - But they may still display output to the terminal and intersperse with your foreground job
                    - You should redirect I/O from background jobs to files
                - The keyboard is only connected to the current, foreground job
        - The built-in jobs command lists background jobs
            - Type `jobs` without the quotes, at the prompt
                - `kill %n` is used to terminate a background job
                    - The 'n' specifies the job number
                        - i.e. kill %1
                - `bg %n` backgrounds a job
                    - i.e. bg %1
                - `fg %n` foregrounds a job
                    - i.e. fg %1

    5.6 - History

        - Shells retain information about former commands entered/executed
        - In C Shell, the commands `history` and `savehist` are used
            - `history`  : Sets the number of previously executed commands to keep
                           track of in this shell 
            - `savehist` : How many commands to retain between logins
                - i.e. set history=100 savehist=50
                    - Saves the last 100 commands in current shell, and the last 50 through the next login
        - The shell keeps track of the history list and saves it in ~/.history, between logins
        - The `history` command is used to recall previous commands
            - i.e. history 10
                - Shows the last 10 commands entered
        - The last command entered can be repeated by typing: !!
        - You can repeat any previously entered command from the history list, using its number
            - i.e. !522
                - Repeats the 522nd command in the history list
        - You can also repeat a command by prefacing the starting unique part of the string with a !
            - i.e. !cle
                - Repeats the `clear` command if its in the history list

        - The following table is a summary of C Shell history substitution characters:

            COMMAND          |    SUBSTITUTION FUNCTION
            -----------------|--------------------------------
            !!               | repeat last command
            !n               | repeat command number n
            !-n              | repeat command n from last
            !str             | repeat command that started with string 'str'
            !?str?           | repeat command with 'str' anywhere on the line
            !?str?%          | select the first argument that had 'str' in it
            !:               | repeat the last command, generall used with a modifer
            !:n              | select the nth argument from the last command
            !:n-m            | select the nth through mth arguments from the
                             |     last command
            !^               | select the first argument from the last command
                             |     (same as !:1)
            !$               | select the last argument from the last command
            !*               | select all arguments to the previous command
            !:n*             | select the nth through last arguments from the
                             |     previous command
            !:n-             | select the nth through next to last arguments from
                             |     the previous command
            ^str1^str2^      | replace 'str1' with 'str2' in its first occurence in
                             |     the previous command
            !n:s/str1/str2/  | substitute 'str1' with 'str2' in its first occurrence
                             |  in the nth command
                             |  Add a 'g' at the end to substitute, globally

    5.7 - Changing your Shell

        - You can change your shell using the `chsh` command, or `passwd -e` command. 
            - Note: The latter only works on select systems, while the former works universally
        - The new shell must be the full path for a valid shell on the system
            - i.e.
                Bourne Shell : /bin/sh
                C Shell      : /bin/csh
                Korn Shell   : /bin/ksh
        - A full list of all available shells can be found in: /etc/shells
            - You can view the file 'shells' using a text editor (i.e. nano)
            - One of these should be your default shell
                - Any other shell will cause problems with `ftpd`, the transfer protocol daemon
                    - `ftpd` allows you to connect to the machine
        - Before fully committing to a new shell, you can try it out by typing its name in the shell; you can execute a different shell as you would any other command
            - i.e. $ tcsh   
                - Switches the shell to 'tcsh' for the current shell
                    - Sub-shells will be the default shell

CHAPTER 6 - Special Unix Features

    - Unix has contributed to operating systems by providing:
        - Utilities to perform common tasks or obtain information
        - A standardized way in which data is stored and transmitted
            - This allows data to be transmitted to a file, the terminal screen, or a program, or from a file, the keyboard, or a program
            - The standardized handling of data supports two important features:
                - Input/Output Redirection
                    - With output redirection, the output of a command is redirected to a file rather than to the terminl screen
                    - With input redirection, the input to a command is given to a file rather than the keyboard
                - Piping
                    - The output of a command can be used is input (piped) to a subsequent command

    6.1 - File Descriptors

        - There are 3 standard file descriptors:
            - stdin  0 : Standard input to the program 
            - stdout 1 : Standard output from the program
            - stderr 2 : Standard error output from the program
        - Normally, input, 'stdin', is from the keyboard or a file
        - Normally, the outputs, 'stdout' and 'stderr', go to the terminal
            - Alternatively, they can be redirected to one or more files
        - You can specify additional file descriptors, designating them by a number 3 
          through 9, and redirect I/O through them

    6.2 - File Redirection

        - Output redirection takes the ouput of a command and places it into a named file
        - Input redirection reads the file as input to the command

        - The following table summarizes the redirection options:

            SYMBOL     | RE-DIRECTION
            -----------|----------------------------------------------------------------
            >          | - Redirects output from the result of the left side to the 
                       |   right side. For example, if you typed the following command 
                       |   into the terminal: ls -la > save.txt 
                       | - It would save the output of `ls -la` into a file called 
                       |   'save.txt'
                       | - Note: If the file does not exist, then it is created
                       | - Note: If the file does exist, then it gets overwritten
            -----------|----------------------------------------------------------------
            >!         | - Same as above, but overrides the noclobber option of csh. 
                       |   In other words, if the file 'save.txt' already exists, it 
                       |   will overwrite it
                       | - For example: echo "" >! save.txt
            -----------|----------------------------------------------------------------
            >>         | - Appends the output from the result of the left side into  
                       |   the right side. For example: echo "The End" >> essay.txt
                       | - It would add "The End" to the end of the file 'essay.txt'
                       |     - The file is not overwritten, it is appended
                       | - Note: If the file does not exist, then it will create the file
            -----------|----------------------------------------------------------------
            >>!        | - Same as above, but overrides the noclobber option on csh. In 
                       |   other words, it will append even if the file already exists. 
                       |   For example: cat math2.txt >>! math1.txt
            -----------|----------------------------------------------------------------
            |          | - Pipes the output from the left command to the right command
                       | - For example:
                       |     set | grep -i bash_version
                       |     find . | grep -i bin*
                       |     cat lines.txt | wc -l
                       | - The syntax for piping is: command_1 | command_2
            -----------|----------------------------------------------------------------
            <          | - Input redirection; the command takes input from the file. 
                       | - For example: 
                       |     wc -l < lines.txt
                       |     grep -i rwx < permiss.txt 
                       | - The command (left side) gets its input from the file (right side)
                       | - The syntax for input redirection is: program < file
            -----------|----------------------------------------------------------------
            <<String   | - Read from standard input until the word "String" is encountered 
                       |   as the only text on the line. Everything typed before "String" is
                       |   used as input for the command. 
                       | - For example:
                       |     cat <<EOF > doc.txt
                       |       - Creates a file called doc.txt and stores all text typed in
                       |         the terminal until "EOF" is encountered on a line by itself
                       |     wc -w <<EOF
                       |       - Counts all words typed in the terminal until "EOF" is 
                       |         encountered on a line by itself
                       | - This is also known as a 'Here Document'
            -----------|----------------------------------------------------------------
            <<\String  | - Same as above, but shell substitutions are not allowed 
                       | - Examples of shell substitutions: $HOME, $PS1, $DISPLAY, etc.
            -----------|----------------------------------------------------------------

        6.2.1 - Csh

            - In C Shell:
                >& file.txt
                    - Redirects 'stdout' and 'stderr' to `file.txt`
                >>& file.txt
                    - Appends 'stdout' and 'stderr' to `file.txt`
                l& command
                    - Pipes 'stdout' and 'stderr' to `command`

                - Example of redirecting 'stdout' and 'stderr' to two separate fles:
                    (command > outFile) >& errFlile
                        - The first redirect, 'stdout' is in a sub-shell

        6.2.2 - Sh

            - The outputs 'stdout' and 'stderr' can be redirected to files or commands or elsewhere. 
                - For example: 
                    command 2> file
                        - Redirects 'stderr' from `command` to 'file'
                    command > file 2>&1
                        - Directs both 'stdout' and 'stderr' from `command` to 'file'
                    command >> file 2>&1
                        - Appends both 'stdout' and 'stderr' from `command` to 'file'
                    command_1 2>&1 | command_2
                        - Pipes 'stdout' and 'stderr' from `command_1` to `command_2`
                    command 1> outFile 2> errFile
                        - Redirects 'stdout' to 'outFile' and 'stderr' to 'errFile'
                    command > outFile 2> errFile
                        - Same as above, but the '1' is not needed because the redirection defaults to 'stdout'

            - With the Bourne shell, you can specify other file descriptors (3 to 9) and redirect output through them. The general form is: n>&m 
                - Redirects file descriptor 'n' to file descriptor 'm'
                    - For Example:
                        (command 3>&2 2>&1 1>&3) > file
                            - 3 is redirected to 2, then 2 redirects to 1, and finally 1 redirects to 3
                                - In effect, this only yields 'stderr'; the error messages
                            - Practical use example:
                                (cat file 3>&2 2>&1 1>&3) > errFile
                                    - If the 'file' is read, then the contents of 'file' are discarded, but if 'file' cannot be read, then the error message is redirected to 'errFile'
                - File descriptors can be closed. For example:
                    m<& :: Closes an input file descriptor
                    <&  :: Closes stdin
                    m>& :: Closes an ouput file descriptor
                    >&  :: Closes stdout

    6.3 - Other Special Command Symbols

        - In addition to file redirection symbols there are a number of other special symbols that can be used. The following table summarizes them:

            SYMBOL      |       DESCRIPTION
            ------------|------------------------------------------------------------
            ;           | - This is a command separator and is used to run multiple
                        |   commands on the same line. 
                        | - The syntax is: command_1; command_2; command_3;
                        | - For example: 
                        |     mkdir newDir; cd newDir; touch code.java
                        |     cd dir1/ ; cd dir2 ; cd dir3
            ------------|------------------------------------------------------------
            &           | - Run the command in the background. The syntax is: command &
                        | - For example:
                        |     grep -ir java /
                        |     find *.hs /
                        | - The output is printed to the terminal, but you can use the 
                        |   terminal and enter in commands. Howver, the output will 
                        |   visually intefere with your ability to use the terminal
            ------------|------------------------------------------------------------
            &&          | - Run two commands, one after another, only if the first
                        |   command completes successfully. The syntax is: 
                        |     command_1 && command_2
                        |     command_1 && command_2 && command_3
                        | - For example:
                        |     grep string file && cat file
                        |     cd hmwk/ && touch unix.txt && nano unix.txt
            ------------|------------------------------------------------------------
            ||          | - Runs two commands, one after another, only if the first
                        |   command did not complete successfully. The syntax is:
                        |   command_1 || command_2
                        | - For example: 
                        |     mkdir code/ || echo "Directory already exists"
                        |     grep string file || echo "String not found"
            ------------|------------------------------------------------------------
            ()          | - The command(s) within the round brackets are executed in
                        |   a subshell . The output of the subshell can be manipulated
                        |   using the above commands. The syntax is: 
                        |     (command)
                        |     (command_1 && command_2)
                        |     (commandX || commandY)
            ------------|------------------------------------------------------------
            ' '         | - These are literal quotation marks. They do not allow any
                        |   special meaning to any characters within these quotes.
                        |   The syntax is: command 'TEXT'
                        | - For example:
                        |     echo '$HOME'
                        |       - Compare the output to: echo $HOME 
            ------------|------------------------------------------------------------
            \           | - This is the escape key. It escapes the following character.
                        |   In other words, take it literally. The syntax is:
                        |   command \SPECIAL_CHARACTER
                        | - For example:
                        |     echo \$HOME
                        |       - Compare the output to: echo $HOME 
                        |     echo I want pizza \& soda
                        |       - Try this command without the escape key ( \ )
            ------------|------------------------------------------------------------
            " "         | - These are regular quotation marks. They allow variable
                        |   and command substitutions with these quotations. 
                        | - For example:
                        |     echo "Bash location: $BASH & Version: $BASH_VERSION"
                        |     echo "My name is: `whoami`, and the date is: `date`"
            ------------|------------------------------------------------------------
            `command`   | - These are backticks, and they take the output of a command 
                        |   and substitutes it as an argument on the command line. 
                        |   The syntax is: command_1 `command_2`
                        | - For example:
                        |     open `pwd`
                        |     echo `pwd`
                        |       - Try these commands without the backticks ( ` )
            ------------|------------------------------------------------------------
            #           | - Everything after this symbol is a comment and is ignored
                        |   by the shell. The syntax is: # Type anything here
                        | - For example:
                        |     # echo This will not be executed
                        |     echo This will execute # But this is ignored
                        | - Comments are good for writing brief descriptions on what
                        |   certain commands do
            ------------|------------------------------------------------------------

    6.4 - Wild Cards

        - The shell allows meta-characters, or wild cards, and replace them with pattern matches. The following table summarizes these meta-characters and their uses:
            
            SYMBOL         |         USES
            ---------------|---------------------------------------------------------
            ?              | - Match any single character at the position. For example:
                           |     ls ?  
                           |       - Lists all files with a single character name
                           |     ls *.???
                           |       - Lists all files that have a 3 letter extension
            ---------------|---------------------------------------------------------
            *              | - Match any string of zero of more characters. For example:
                           |     ls *.*
                           |       - Lists all files that have a dot in their name
                           |     ls *
                           |       - Lists all files, sub-directories, and files inside
                           |         those sub-directories
            ---------------|---------------------------------------------------------
            [abc]          | - Match any of the enclosed characters. For example:
                           |     ls [f]*
                           |       - Lists all files that start with an 'f'
                           |     ls [f]*[t]
                           |       - Lists all files that start with an 'f' and end
                           |         in a 't'
            ---------------|---------------------------------------------------------
            [a-e]          | - Match any characters in the range: a, b, c, d, e
                           | - For example:
                           |     ls [a-m]*
                           |       - Lists all files that start with a character in 
                           |         the range 'a' - 'm' (i.e. 'b', 'c', 'd', etc.)
                           |     ls [p-r]*
                           |       - Lists all files that start with 'p', 'q', or 'r'
            ---------------|---------------------------------------------------------
            [!def]         | - Match any characters not one of the enclosed 
                           |   characters. For example:
                           |     ls [!f]*
                           |       - Lists all files that do not start with 'f'
                           |     ls [!a-m]*
                           |       - Lists all files do not start with 'a' - 'm'
                           | - This is only in Bash (sh)
            ---------------|---------------------------------------------------------
            {abc,bcd,cde}  | - Match any set of characters separated by comma. 
                           | - For example:
                           |     ls {a,p,f}*
                           |       - Lists all files that start with a 'a', 'p', or 'f'
                           |     ls *.{j,p,c}*
                           |       - Lists all files that end in a letter starting with
                           |         'j', 'p', or 'c'
                           | - Note: Do not separate items with a space, only commas
            ---------------|---------------------------------------------------------
            ~              | - Home directory of current user. For example:
                           |     cd ~
            ---------------|---------------------------------------------------------
            ~user          | - Home directory of specified user. For example:
                           |     cd ~JimBob
            ---------------|---------------------------------------------------------

CHAPTER 7 - Text Processing

    7.1 - Regular Expression Syntax

        - Text processing programs such as `grep`, `egrep`, `sed`, `awk`, and `vi`, can search on patterns instead of fixed strings. 
            - These text patterns are known as regular expressions 
                - Text patterns are created by combining normal characters and special characters
                    - Special characters are also known as meta-characters
                        - This was briefly discussed in 6.4
                - Regular expressions come in three different forms:
                    - Anchors: Tie the pattern to a location on the line
                    - Character Sets: Match a character at a single position
                    - Modifiers: Specify how many times to repeat the previous expression
            - Note: `egrep` is extended-grep which allows for more meta-characters
                - Examples are below
        - Regular expression syntax is as follows:
            .
                - Match any character expect <newline>
            *
                - Match zero or more instance of the single character, or meta-character, immediately preceding it
            [abc]
                - Match any of the characters enclosed
            [a-d]
                - Match any character in the enclosed range
            [^exp]
                - Match any character not in the following expression 
            ^abc
                - The regular expression must start at the beginning of a line
            abc$
                - The regular expression must end at the end of a line
            \
                - Treats the next character literally
                    - Normally used to escape the meaning of special characters such as '.' and '*'
            \{n,m\}
                - Matches the regular expression preceding this a minimum number of 'n' times and a maximum number of 'm' times. 
                    - 'n' and 'm' are limited to 0 - 255
                    - Note: The backslash, does not escape the curly brackets
                        - The '\{' and '\}' should be thought of as single operators
            \<abc\>
                - Matches the enclosed regular expression as long as it is a separate word. For instance, if the regular expression is \<ron\>, then it will match "ron", and NOT "iron". 
                    - Word boundaries are defined as beginning with a <newline> or end-of-line character\
                        - Letters, digits, underscores, etc. are not allowed
                    - Note: The backslash, does not escape the angle brackets
                        - The '\<' and '\>' are single operators
            \(abc\)
                - Saves the enclosed pattern in a buffer
                    - Up to nine patterns can be saved for each line
                        - Patterns can be referenced later with the '\n' character set
                            - Note: '\n' is not <newline> in the context of regular expressions
                    - Note: The '\(' and '\)' are single operators
            \n 
                - Matches the n'th expression previously saved for each line 
                    - n' is between 1 and 9
                    - Expressions are numbered starting from the left
                        - Note: '\n' should be thought of as a single operator
                - '\n' is not <newline> in the context of regular expressions
            &
                - Prints the previous search pattern
            
            - The following meta-characters are only used by `awk` and `egrep`:
                +
                    - Matches one or more of the preceding expression(s)
                ?
                    - Matches zero or more of the preceding expression(s)
                |
                    - Match either the preceding or following expression
                        - This is a separator
                        - Similar to the '||' symbol
                ()
                    - Group the regular expressions within and apply the match to the set

    7.2 - Text Processing Commands

        - The following summarizes commonly used text processing commands:
            - awk [options] [fileName]
                - Scan for patterns in a file and process the results
            - nawk [options] [fileName]
                - Same as `awk` but newer and contains more features/functions
            - grep [options] [searchString] [fileName(s)]
                - Search [fileName] for all occurences of [searchString] and list them
            - egrep [options] [searchString] [fileName(s)]
                - Same as `grep` but contains more meta-characters
                    - More powerful than `grep`
                    - The 'e' stands for extended
                - `grep -e` is the same as egrep
            - fgrep [options] [searchString] [fileName(s)]
                - Same as `grep` but searches for an exact string instead of pattern matching
                    - Compromises functionality for speed
                    - The 'f' stands for fixed
                - `grep -f` is the same as fgrep
            - sed [options] [fileName]
                - Stream editor for editing files from a script or the command line

        7.2.1 - grep

            - The `grep` utility is used to search for generalized regular expressions occuring in Unix files
                - When using `grep`, regular expressions are best specified in single quotes
            - The `egrep` utility provides searching capability using an extended set of meta-characters

            - Syntax for `grep`: grep [options] [regularExpression] [fileName(s)]
                grep shakespear essay.txt 
                    - Searches the 'essay.txt' file for the expression "shakespear"
                grep "dog" animals.txt mammals.txt
                    - Searches 'animals.txt' and 'mammals.txt' for the expression "dog"
                grep '15' listOfNumbers.txt
                    - Searches 'listOfNumbers.txt' for the expression "15"
                grep 'te*' num.list
                    - Searches for any instances of 't' followed by zero or more occurrences of 'e'
                grep 'tee*' num.list
                    - Searches for any instances of 't' followed by one or more occurrences of 'e'

            - Using piping, `grep` can also search the output of commands
                - i.e.
                    who | grep "console"
                    set | grep "BASH_VERSION"
                    ls  | grep .txt 

            - Some flags for `grep`:
                grep -i william book.txt
                    - Ignores case when pattern matching
                        - i.e. william, William, WiLLiam, williaM, wIllIam, etc. are the same
                grep -r databases .
                    - Recursively searches through all files in the directory and sub-directories
                        - Searches all files in current directory and its sub-directories for the expression "databases"
                            - Note: The dot ( . ) means current directory
                grep -c Jim book.txt
                    - Reports how a count of many matches were found, not the actual matches
                        - i.e. How many times was 'Jim' found in 'book.txt'
                grep -v true lab.txt
                    - Only outputs lines that do NOT match the expression
                        - i.e. Every line in 'lab' that DOES NOT contain 'true'
                grep -n unix summary.txt
                    - Each match is preceded by its relative line number
                        - i.e. Displays every line the word 'unix' appears in 'summary.txt'
                grep -s display drivers.txt
                    - Silent mode; only reports the final status
                        - i.e.
                            - 0 :: Matches Found
                            - 1 :: No Matches Found
                            - 2 :: Error(s)
                grep -E regularExpression files
                    - Forces `grep` to behave like `egrep`
                        - `egrep` is extended `grep`
                grep -F regularExpression files
                    - Forces `grep` to behave like `fgrep`
                        - `fgrep` is fixed `grep`

            - Note: The syntax for the commands `egrep` and `fgrep` are identical `grep` syntax

        7.2.2 - sed

            - The `sed` command is a non-interactive stream editor that edits the input stream, line by line, making the specified changes, and sends the result to standard output

            - Syntax for `sed` is: sed [options] [EDIT_COMMAND] [fileName]
                - The format for [EDIT_COMMAND] is: [address1,[address2]][function][arguments]
                    - Addresses are optional and can be separated from the function by spaces or tabs
                    - The function is required
                    - The arguments may be optional or required, depending on the function in use
                - Line Number Addresses are decimal line numbers, starting from the first input line and incremented by one for each
                    - The last input line can be specified with the '$' character
                - Context Addresses are the regular expression patterns enclosed in slashes ( / )
                - Commands can have 0, 1, or 2 comma separated addresses with the following affects:
                    - 0 :: Every line of input
                    - 1 :: Only lines matching the address
                    - 2 :: First line matching the first address and all lines until, and including, the line matching the second address
                        - This process is repeated on subsequent lines
                - Substitution functions allow context searches and are specified in the form: 
                    s/regularExpressionPattern/replacementString/flag
                        - Single quotes must be used if additional options/functions are specified
                        - 'replacementString' is not a regular expression pattern
                        - Only the following characters have special meaning:
                            - &  :: Substitute the string specified by 'regularExpressionPattern'
                            - \n :: Substitute the n'th string matched by 'regularExpressionPattern'
                                - These special characters, '&' and '\n' can be escaped with a backslash
                - Some arguments for `sed`:
                    `-E` :: Interprets regular expression as extended regular expression
                    `-n` :: Suppresses default output (i.e. Do not print to terminal)
                    `-e` :: Perform multiple operations
                    `-i` :: Edits the actual file, instead of printing changes to terminal
                                - Changes are permanent
                                    - Should be used after trying/testing out the change(s)
                                - Adding a suffix will create a backup of the original file
                                    - i.e. `-i.bak`
                - Valid flags on the substitution function:
                    `d`  :: Delete the pattern
                    `g`  :: Globally substitute the pattern
                    `p`  :: Print the line
            - Examples of `sed`:
                sed 's/?/\!/g' essay.txt
                    - Changes all incidences of a '?' to a '!' in 'essay.txt'
                    - Note: The changes are not made to the file 'essay.txt'
                        - This shows you the changes that can be made
                sed 's/\ Jr//g' essay.txt
                    - Deletes all instances of ' Jr' in 'essay.txt'
                    - Note: The changes are not made to the file 'essay.txt'
                        - This shows you the changes that can be made
                sed -i.bak2 s/\Boys/Men/g essay.txt
                    - Replaces all occurences of the regular expression 'Boys' with 'Men'
                        - The changes are permanent 
                            - Due to the `-i` flag
                            - A backup file called 'essay.txt.bak2' is created
                sed -e 's/Date/Date:/g' -e 's/From/From:/g' essay.txt
                    - Performs multiple edits to 'essay.txt'
                        - Replaces 'Date' with 'Date:'
                        - Replaces 'From' with 'From:'
                    - Changes are not permanent
                sed -n 1,10p fileName.txt
                    - Prints the first 10 lines of 'fileName.txt'
                        - Works exactly like the `head` command

        7.2.3 - awk, nawk, gawk

            - The command `awk` is a pattern scanning and processing language
                - `awk` searches its inputs for patterns and performs the specified operation on each line or fields of the line that contain those patterns
                    - Patterns are enclosed in curly braces ( { } )
                        - An action and a pattern form a rule
                            - The entire `awk` rule is enclosed in single quotes ( ' )
                - `nawk` is a newer version of `awk`
                - `gawk` is GNU's version of `awk`
                    - Each version is a little different
            - By default, `awk` considers a field to be a string of characters surrounded by whitespace, the start of a line, or the end of a line
                - Fields are identified by a dollar sign
                    - i.e. $1 represents the first field

            - Syntax for `awk`: awk [program] [file]
                - Where [program] is composed of one or more 'pattern {action}' fields
                    - Each input line is checked for a pattern match with the indicated action being taken on a match
                 - Inputs are divided into records and fields
                    - Records:
                        - The default record separator is <newline> 
                            - The variable NR keeps the record count
                                - NR stands for number of records
                    - Fields: 
                        - The default field separator is whitespace, spaces, and tabs
                            - The variable NF keeps the field count
                                - NF stands for number of fields
                                    - '$NF' represents the last field
                    - '$n', where 'n' is an integer is used to represent the 'n' field of the input record
                        - $0 represents the entire record
                - The default output field separator is a space
                    - This can be changed to forward slash, hyphen, underscore, etc.
                -  'BEGIN' and 'END' are special patterns
                    - A 'BEGIN' rule is executed once, before any text processing starts
                    - An 'END' rule is executed after all processing has completed
                        - You can have multiple 'BEGIN' and 'END' rules, and they will execute in order
                - Printing is done through the `print`, and `printf` commands
                    - Note: `printf` is formatted print
                - Input field separators are used to handle text/data that does not use whitespace to separate fields.  
                    - For example:
                        - CSV files use commas ( , ) to separate values
                        - The file /etc/passwd uses a colon ( : ) to separate fields/text
                - Adding Patterns
                    - Patterns can filter out entries
                        - i.e. Only print user IDs that are greater than 1000
                        - i.e. Only print accounts if last name is greater than 'M'
                    - Note: Patterns are full fledged regular expressions
                - Built In Functions
                    - 'awk' has many functions that you can call and use in your own scripts
                        - For example: 'sqrt', 'atan2', 'cos', 'sin', etc.
                            - Detailed usage examples below
                - Examples:
                    awk '{print $1}' bigData.txt
                        - Prints the first field (column) in 'bigData.txt'
                    ls | awk '{print $0}'
                        - Prints all the contents of `ls` in a vertical format
                            - Similar to `ls -1`
                    ls -la | awk '{print $1}'
                        - Prints the first field/column from the output of the `ls -la` command
                            - The first field is file permissions (i.e. -rwx, -rw-, -r--, etc.)
                    ls -la | awk '{print $9, $5, $1}'
                        - Prints the ninth, fifth, and first fields from the output of the `ls -la` command
                            - The fields printed are: "File name", "File size in bytes", and "Permissions"
                        - Note: A comma between each field puts a space between the fields
                    who | awk '{print $NF}'
                        - Prints the last field from the output of `who`
                            - The last field is the fifth field
                    date | awk 'OFS="/" {print$3,$2,$4}'
                        - Prints the date in the format MM/DD/YYYY, with a forward slash being the field separator value
                    who | awk 'BEGIN {print "Active Sessions"} {print $1,$5} END {print "EOF"}'
                        - The 'BEGIN' rule prints "Active Sessions"
                        - The pattern actions print out the first and fifth fields on `who`
                        - The 'END' rule prints out "EOF", indicating the end of output
                    awk -F: 'OFS=" | " {print $1, $5}' /etc/passwd 
                        - Prints the first and fifth field in the 'passwd' file
                            - The `-F:` indicates that the colon ( : ) is the field separator value
                            - The output field separator is a pipe ( | ) with two spaces on each side
                    awk -F: 'OFS=" | ", $3 >= 200 {print $1, $5}' /etc/passwd 
                        - The `$3 >= 200` filters the output by only printing records where the value of the third field is greater than or equal to 200
                        - The output field separator is a pipe ( | ) with two spaces between it
                        - Fields 1 and 5 are printed to the terminal
                    awk -F: 'BEGIN {print "\n------------\nInformation\n------------\n"} OFS=" | ", $3 >= 200 {print $1, $5} END {print "\n---\nEOF\n---"}' /etc/passwd 
                        - Same as above, but more programs are included (i.e. 'BEGIN', 'END', Etc.)
                    awk 'BEGIN {print sqrt(625)}'
                        - Uses the built in square root function to calculate the square root of 625 and then prints it to console
                    awk 'BEGIN {print atan2(0, -1)}'
                        - Uses the built in function 'atan2'
                    awk 'BEGIN {print sin(6.28/4)/cos(0)}'
                        - Uses the built in function 'sin' and 'cos'

                - More information & examples: 
                https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/

CHAPTER 8 - Other Useful Commands

    8.1 - Working With Files

        - Below is a summary of commands that are useful in examining and manipulating the contents of files:

            - cmp [options] [file1] [file2]
                - Compares two files and lists where the differences occur
                    - Files can be text or binary
            - cut [options] [file(s)]
                - Cuts the specified field(s)/character(s) from the lines in file(s)
            - diff [options] [file1] [file2]
                - Compares the two files and displays the differences
                    - Can only be used on text files
            - file [options] [file]
                - Classifies the file type
            - find [options] [actions] [file]
                - Finds files/directories matching a type or pattern
            - ln [options] [source_file] [target]
                - Links the [source_file] to the [target]
            - paste [options] [fileName]
                - Paste field(s) onto the lines in [fileName]
            - sort [options] [fileName]
                - Sort the lines of [fileName] according to the option(s) provided
            - strings [options] [file]
                - Report any sequence of 4 or more printable characters ending in <NL> or <NULL>
                    - Usually used to search binary files for ASCII strings
                        - Binary files are compiled code
            - tee [options] [file]
                - Copy 'stdout' to one or more files
            - touch [options] [date] [file]
                - Create an empty file, or update the access time of an existing file
            - tr [options] [string1] [string2]
                - Translate the characters in [string1] from 'stdin' into those in [string2] in 'stdout'
            - uniq [options] [file]
                - Remove repeated lines in a file
            - wc [options] [file(s)]
                - Display word/character/line count for [file(s)]

        8.1.1 - cmp - compare file contents

            - The `cmp` command compares two files, the location of the (first) difference between them
                - Can deal with binary and text files
                    - Compares the files byte-by-byte
                - Useful for determining which version of a file should be kept, if there is more than one version

            - Syntax for `cmp`: cmp [options] [file1] [file2]
                cmp file1.txt file2.txt
                    - Outputs where the differences between 'file1.txt' and 'file2.txt' are
                        - i.e. char 15, line 1
                cmp file1.txt file2.txt 2 4
                    - Same as above but skips the first 2 bytes in 'file1.txt' and first 4 bytes in 'file2.txt'

            - Some flags for `cmp`:
                cmp -v
                    - Prints version information for `cmp`
                cmp --help 
                    - Prints helper information
                cmp -i 10 [file1] [file2]
                    - Skips the first 10 bytes of [file1] and [file2]
                cmp -l [file1] [file2]
                    - Outputs byte numbers and values of all differing bytes.
                cmp -s [file1] [file2]
                    - Silent mode
                        - Does not output byte differences
                            - Outputs exit status only
                cmp -b [file1] [file2]
                    - Prints differing bytes

        8.1.2 - diff - differences in files

            - The `diff` command compares two files, directories, etc. and reports all differences between the two
                - Only works with ASCII files
                - Compares files line by line

            - Syntax for `diff`: diff [options] [file1] [file2]
                diff version1.txt version2.txt
                    - Reports all differences between 'version1.txt' and 'version2.txt'
            
            - Some flags for `diff`:
                diff -i lower.txt upper.txt
                    - Ignores the case of letters when comparing content of 'lower.txt' and 'upper.txt'
                diff -w roughCopy.txt finalCopy.txt
                    - Ignores all white space (spaces, tabs, etc.) when comparing files
                diff -r program1/ program2/
                    - Recursively compares subdirectories

        8.1.3 - cut - select parts of a line

            - The `cut` command cuts out a selected portion of a file and prints it to 'stdout' (standard output)
                - Selected text can be redirected to another file

            - Syntax for `cut`: cut [options] [list] [fileName]
                cut -b 4 users.txt
                    - Cuts the 4th byte from 'users.txt' and prints it to the terminal
                cuts -b 5-9 users.txt
                    - Cuts the 5th, 6th, 7th, 8th, and 9th byte from 'users.txt' and prints it
                cut -c 6 people.txt
                    - Cuts the 6th character from 'people.txt' and prints it
                cut -c 10-15 people.txt
                    - Cuts all characters from 10 to 15th, in 'people.txt', and prints it
                cut -f 1 tasks.txt
                    - Cuts the 1st field from 'tasks.txt' and prints it

        8.1.4 - paste - merge files

            - The `paste` command allows two files to be combined side-by-side
                - The default delimiter between the columns is <TAB>
                    - Although, the delimiter can be changed

            - Syntax for `paste`: paste [options] [file1] [file2]
                paste users.txt phones.txt
                    - Merges text from 'users.txt' and 'phones.txt' and prints it to the terminal
                paste users.txt phones.txt > data.txt
                    - Same as above, but outputs the result to 'data.txt'

            - Some flags for `paste`:
                paste -d \# users.txt phones.txt
                    - Uses the '#' as the delimiter
                paste -s users.txt phones.txt
                    - Uses newline ( \n ) as the delimiter

            - When piping to `paste`, use the hyphen ( - ) as a placeholder for the input field

        8.1.5 - touch - create a file

            - The `touch` command can be used to create a new (empty) file or update the last access time on an existing file
                - `touch` is primarily used when a script:
                    - Requires the pre-existence of a file
                    - Is checking for last date or time a function was performed 

            - Syntax for `touch`: touch [options] [fileName]
                touch file.txt
                    - Creates a new empty file called 'file.txt'
                touch search.py gui.java backend.cpp
                    - Creates three empty new files: 'search.py', 'gui.java', 'backend.cpp'

            - Some flags for `touch`:
                touch -f unix.txt
                    - Tries to force the update, even if the file permissions do not permit it

        8.1.6 - wc - count words in a file

            - The `wc` command is used to count the number of lines, characters, words, or bytes in a file

            - Syntax for `wc` is: wc [options] [fileName]
                wc users.txt
                    - Counts the number of lines, words, and bytes in 'users.txt' and prints it
                wc commands.txt unix.txt
                    - Prints the number of lines, words, and bytes in 'commands.txt' and 'unix.txt', and prints the total (sum)

            - Some flags for `wc`:
                wc -c essay.txt
                    - Counts the number of bytes in 'essay.txt' and prints it
                wc -l essay.txt
                    - Counts the number of lines in 'essay.txt' and prints it
                wc -w essay.txt
                    - Counts the number of words in 'essay.txt' and prints it

        8.1.7 - ln - link to another file

            - The `ln` command creates a link or an additional way to access another file
                - There are two types of links:
                    - Hard links: Are indistinguishable from the original directory entry
                    - Symbolic links: Contains the name of the file to which it is linked
                - By default, `ln` makes hard links

            - Syntax for `ln`: ln [options] [source] [target]
                - ln /etc/hosts hosts.link
                    - Creates a link called 'hosts.link' to the 'hosts' file
                        - 'hosts.link' is created in current directory
                - ln /etc/fstab.hd
                    - Creates a link to 'fstab.hd'
                        - Link is called 'fstab.hd' and is created in current directory

            - Some flags for `ln`:
                ln -s /etc/hosts
                    - Creates a symbolic link
                ln -v /etc/hosts
                    - Causes `ln` to be verbose, and shows files as they are processed
                ln -f /etc/hosts
                    - If the target file already exists, then unlink it so that the new link can be created

        8.1.8 - sort - sort file contents

            - The `sort` command is used to order the lines of a file
                - Default sorting algorithm outputs the files in ASCII order
                    - i.e. Numbers first, upper case letters, then lower case letters
                        - Various flags can change this order

            - The syntax for `sort` is: sort [options] [file]
                sort list.txt
                    - Sorts the lines in 'list.txt' using default ASCII order

            - Some flags for `sort`:
                sort -b list.txt
                    - Ignores leading blanks when sorting
                sort -f list.txt
                    - Ignores case when sorting
                        - Folds lowercase characters to uppercase when sorting
                sort -r list.txt
                    - Reverses the sorting order
                sort -o output.txt list.txt
                    - Sorts the file 'list.txt' and saves the result to 'output.txt'
                sort -u file.txt
                    - Omits multiple copies of the same line; only unique lines allowed
                sort --version
                    - Prints version information
                        - Does not sort any file

        8.1.9 - tee - copy command output

            - The `tee` command sends 'stdin' to specified files and also to 'stdout'
                - In other words, it can output to files and the terminal, at the same time
                    - Commonly used for piping commands

            - The syntax for `tee` is: tee [options] [file(s)]
                who | tee users.file
                    - Prints the output of `who` to the terminal and saves it to 'users.file'
                ls -1 | tee files.txt files.back.txt | wc -l
                    - Prints number of lines `ls -1` produces and saves the output of `ls -1` to 'files.txt' and 'files.back.txt'

            - Some flags for `tee`: 
                who | tee -a users.file
                    - Append the output to 'users.file' instead of overwriting it
                who | tee -i users.file
                    - Ignores interrupts

        8.1.10 - uniq - remove duplicate lines

            - The `uniq` command reports or filters out repeated lines in a file

            - The syntax for `uniq` is: uniq [options] [input_file] [output_file]
                uniq list.txt
                    - Prints 'list.txt' to terminal without the duplicate lines
                uniq list.txt newList.txt
                    - Filters 'list.txt', removes duplicates, and outputs result to 'newList.txt'

            - Some flags for `uniq`:
                uniq -c list.txt
                    - Precedes each output line with the count of the number of times the line occurred in the input, followed by a single space
                uniq -d list.txt
                    - Only outputs lines that are repeated in the input
                uniq -f 5 list.txt
                    - Ignores the first 5 fields in each input line when doing comparisons
                uniq -s 10 list.txt
                    - Ignores the first 10 characters in each input line when doing comparisons
                uniq -i list.txt
                    - Case is ignored when comparing lines

        8.1.11 - strings - find ASCII strings

            - The command `strings` is used to search a binary file for printable ASCII strings
                - `strings` searches for any sequence of 4 or more ASCII characters terminated by a <newline>
                - This command is useful for searching for file names and possible error messages within compiled programs, where the source is not available

            - The syntax for `strings` is: strings [option] [file]
                strings binaryFile
                    - Prints every single ASCII string in [binaryFile] to console
                strings Application.exe | grep -in "money"
                    - The output of `strings Application.exe` is passed to `grep`, where it finds the occurence(s) of "money", if any

            - Some flags for `strings`:
                strings -a game 
                    - Looks for strings in 'game', in all sections of the object/binary file
                        - i.e. The (__TEXT, __text) sections
                strings -o models
                    - Each string is preceded by its offset in the file 'models'
                        - Offset is printed in decimal
                strings -t x models
                    - Each string is preceded by its hexadecimal offset
                strings -n 10 engine
                    - Sets the minimum length of the string to 10
                        - Default is 4

        8.1.12 - file - file type

            - The `file` determines the file type of a selected file
                - It does this by testing each argument in an attempty to classify it
                    - There are three types of tests (performed in order:
                        - Filesystem Test: Examines the return value from a system call
                        - Magic Test: Checks for files with data in particular fixed formats
                        - Language: Determines what language the file is written in
                    - The first test to succeed causes the file type to be printed

            - The syntax for `file` is: file [options] [file]
                file /etc/hosts
                    - Determines the file type of the 'hosts' file
                        - Returns 'ASCII English Text'
                file Program
                    - Determines the file type of the executable 'Program'
                        - Returns 'Mach-O 64-bit executable x86_64'

            - Some flags for `file` are:
                file -d list.txt
                    - Applies default system tests when determining file type for 'list.txt'
                file -D list.txt
                    - Prints debugging messages
                file -L hosts.link
                    - Follows symbolic links
                file -z archive.zip
                    - Extract 'archive.zip' and tries to inspects its contents
                file -v
                    - Prints the version of the program and exits
                        - Does not check files
                file --help
                    - Prints a help message and exits
                        - Does not check files

        8.1.13 - tr - translate characters

            - The `tr` command translates characters from 'stdin' to 'stdout'
                - i.e. Convert 'abc' to 'ABC'
                    - Translation is done by substituting or deleting selected characters

            - The syntax for `tr` is: tr [options] [string1] [string2]
                echo "a fast way" | tr 'a' 'A'
                    - Converts all lowercase 'a' in "a fast way" to uppercase 'A'
                cat file.txt | tr 'aeiou' 'AEIOU'
                    - Converts all lowercase vowels in 'file.txt' to uppercase letters
                cat essay.txt | tr '[a-z]' '[A-Z]'
                    - Converts all lowercase letters to uppercase letters in 'essay.txt'

            - Some flags for `tr`: 
                cat file.txt | tr -d 'XYZ'
                    - Delete all characters in 'XYZ', in 'file.txt'
                cat file.txt | tr -C 'abcdef' 'ghijkl'
                    - Takes the complement of 'abcdef'; every character not in 'abcdef'

        8.1.14 - find - find files

            - The `find` command recursively searches a given directory to find files matching a type or pattern
                - `find` can list files or execute commands based on the results

            - The syntax for `find` is: find [options] [directory] [search_options]
                find program.c
                    - Tries to find 'program.c' in the current directory
                find *.java
                    - Searches current directory for all files ending in '.java'
                find . -newer work.txt -print
                    - Finds all files, in current directory, that are newer than 'work.txt' and prints them to 'stdout'
                find . -newer main.java -print -exec cat {} \;
                    - Finds all files, in current directory, that are newer than 'main.java' and prints their contents using `cat` to 'stdout'

            - Some flags for `find`:
                find -E list.txt
                    - Uses `egrep` instead of `grep` to search for 'list.txt'
                find -s main*
                    - Causes `find` to traverse the directories in lexicographical order when searching for the expression 'main'
                        - Lexicographical order = Alphabetical order

    8.2 - File Archiving, Compression and Conversion

        - Below is a summary of commands that are useful in archiving, compressing, and converting:
            - compress [options] [file] 
                - Compress the file: [file]
                    - Adds a '.Z' suffix to the end of the file name
            - uncompress [options] [file]
                - Uncompresses the file: [file]
                    - Removes the '.Z' suffix and restores the file to the original version
            - zcat [options] [file]
                - Compression/decompression tool using Lempel-Ziv coding
                    - '.Z' is appended to all filenames affected by `zcat`
            - dd [options] [file]
                - Copy and converts a file from ASCII to EBCDIC (or vice versa) 
                    - Can also swap byte order
            - gzip [options] [file]
                - Compress or uncompress a file ending in '.gz' or '.z'
                    - Compressed files are stored with a '.gz' or '.z' ending
            - gunzip [options] [file]
                - Same as `gzip`
            - od [options] [file]
                - Octal dump a binary file, in octal, ASCII, hex, decimal, or character mode
            - tar [options] [file(s)]
                - Tape archiver; used for creating, listing, and retrieving from archive files
            - uudecode [fileName]
                - Decodes a 'uuencoded' file, recreating the original file
            - uuencode [file] [new_name]
                - Encodes a binary file to 7-bit ASCII
                    - Useful when sending files via email

        8.2.1 - File Compression

            - The `compress` command is used to reduce the amount of disk space utilized by a file
                - This is accomplished by compressing it
                    - A suffix of '.Z' is added to the file name
                    - Ownership modes, access, and modification times of the original file are preserved
            
                - The syntax for `compress` is: compress [options] [file(s)]
                    compress code.java
                        - Compresses the file 'code.java' and creates 'code.java.Z'
                    compress main.py functions.py
                        - Compresses the files 'main.py' and 'functions.py', and creates 'main.py.Z' and 'functions.py.Z'

                - Some flags for `compress`:
                    compress -f someFile.txt
                        - Compresses the file 'someFile.txt' and overwrites any existing files without confirmation
                        - The file 'someFile.txt' is compressed even if there is no reduction in size
                    compress -v someFile.txt
                        - Prints the percentage reduction of 'someFile.txt'

            - The `uncompress` command restores the file(s) that were originally compressed by the `compress` command

                - The syntax for `uncompress` is: uncompress [options] [file(s)]
                    uncompress code.java.Z
                        - Uncompresses the file 'code.java.Z' and restores the original file 'code.java'
                    uncompress main.py.Z functions.py.Z
                        - Uncompresses the files 'main.py.Z' and 'functions.py.Z' and restores the original files 'main.py' and 'functions.py'

            - The `zcat` command can be used to display the contents of a file compressed by `compress` 
                - Writes to standard output; 'stdout'
                - Attempting to display the contents of a '.Z' file yields unreadable output

                - The syntax for `zcat` is: zcat [file].Z
                    zcat someFile.txt.Z
                        - Outputs the contents of 'someFile.txt.Z' to 'stdout'
                    zcat someCode.cpp.Z
                        - Outputs the contents of 'someCode.cpp.Z' to 'stdout'
                    - Note: The file must end in '.Z', which indicates that it has been compressed by `compress`

            - In addition to the standard Unix `compress`, `uncompress`, and `zcat` utilities, there are a set of GNU utilities that do a better job of compression, using a more efficient algorithm
                - The utilities are: `gzip`, `gunzip`, and `zcat`
                    - Files compressed with `gzip` are given the endings '.z' or '.gz'
                    - Note: 
                        - `gzip`   == g - zip
                        - `gunzip` == g - unzip
 
        8.2.2 - tar - archive files

            - The `tar` command combines files into one device or filename for archiving purposes
                - It does not compress the files
                - `tar` makes managing a large quantity of files more manageable

            - The syntax for `tar` is: tar [options] [directory] [flags]
                - The options/flags need to be specified
            
            - Using `tar`:
                - List all files in a tar archive
                    tar -tf tarFile.tar
                - Extract tar archive
                    tar -xf tarFile.tar
                - Create tar archive
                    tar -cf nameOfArchive.tar file_1 file_2 ... file_N
                        - The files combined are 'file_1', 'file_2', and all files up to 'fileN'
                        - The archive created is called 'nameOfArchive.tar'
                - Print helper information
                    - tar --help

            - Some flags for `tar`:
                - tar -xf tarFiles.tar -v
                    - Verbose mode; prints all extracted files to 'stdout'
                - tar -xf tarFiles.tar -w
                    - Interactive mode; asks for confirmation before extracting an individual file
                - Note: Some flags only work on specific mode. For instance, verbose and interactive mode do not work when creating tars

        8.2.3 - uuencode/uudecode - encode a file

            - The `uuencode` command encodes a binary file into a 7-bit ASCII file
            - The `uudecode` command decodes the 7-bit ASCII file back to a binary file
                - Both commands are part of the Unix-to-Unix CoPy set of commands
                    - They are commonly used when sending binary files through e-mail
                        - Ensures that the files are transferred and recieved cleanly

            - Syntax for `uuencode`: uuencode [source_file] [currentDirectory] > [new_file_name]
                uuencode cydia.tar ~/Desktop/files/ > encodedFile
                    - Encodes 'cydia.tar' and saves output to 'encodedFile'
            - Syntax for `uudecode`: [ -p ] encoded_file
                uudecode -p encodedFile
                    - Decodes 'encodedFile' and prints to 'stdout'
                uudecode -p encodedFile > deco_File
                    - Same as above but outputs to 'deco_File'

            - Some flags for `uuencode`:
                uuencode -m cydia.tar ~/Desktop/files/ > encodedFile
                    - Uses the Base64 method of encoding
                uuencode -o encoded_file cydia.tar ~/Desktop/files/
                    - Outputs to 'encodedFile' instead of 'stdout'

            - Some flags for `uudecode`:
                uudecode -ip encodedFile
                    - The `-i` flag does not overwrite files

        8.2.4 - dd - block copy and convert

            - The `dd` command allows you to copy from raw devices, such as disks and tapes
                - `dd` was originally known as disk-to-disk copy program

            - Syntax for `dd`: dd [if=input_device] [of=output_device] [operand=value]

            - Common options:
                if=input_device
                    - The input file or device
                of=output_device 
                    - The output file or device
                ibs=n
                    - Input block size
                obs=n
                    - Output block size
                bs=n
                    - Sets both input and output block sizes
                files=n 
                    - Copy 'n' input files
                skip=n 
                    - Skip 'n' input blocks before starting to copy
                count=n 
                    - Only copy 'n' input blocks

            - Example:
                dd if=/dev/rmt/0 of=/dev/rmt/1 
                    - Copies files from one tape drive to another

        8.2.5 - od - octal dump of a file

            - The command `od` dumps a file to 'stdout' in different formats, including:
                - Octal
                - Decimal
                - Floating Point
                - Hex
                - Character Format

            - Syntax for `od`: od [options] [file]
                od file.txt
                    - Outputs octal shorts
                        - Equivalent to: `od -B file.txt`
                od -b file.txt
                    - Outputs octal bytes
                od -D file.txt
                    - Outputs unsigned decimal ints
                od -H file.txt
                    - Outputs hexadecimal ints
                od -i file.txt
                    - Outputs signed decimal ints
                od -c file.txt
                    - Outputs single byte characters

    8.3 - Remote Connections

        - Below is a summary of commands used for establishing remote connection
            - finger [options] [user]@[hostname]
                - Reports information about users on local and remote machines
            - ftp [options] [host]
                - Transfers file(s) using file transfer protocol
            - rcp [options] [hostname]
                - Remotely copy files from this machine to another machine
            - rlogin [options] [hostname]
                - Login remotely to another machine
            - rsh [options] [hostname]
                - Runs a remote shell on another machine
            - telnet [host [port]]
                - Communicates with another host using telnet protocol

        8.3.1 - TELNET and FTP - remote login and file transfer protocols

            - TELNET and FTP are Application Level Internet protocols
                - TELNET is used to login remotely to other computers connected to the Internet
                    - SSH is a more secure version of TELNET
                - FTP is used to transfer files between computers on the Internet

            Syntax for `telnet`: telnet [options] [remote_host [port_number]]
                telnet oscar.us.ohio-state.edu
                    - `telnet` defaults to port 23
            Syntax for `ftp`: [options] [remote_host]
                ftp magnus.acs.ohio-state.edu

            Common Options:
                -d  :: Set debugging mode on
                -i  :: Turn off interactive prompting
                -n  :: Do not attempt to auto-login on connection
                -v  :: Turn on verbose mode

        8.3.2 - finger - get information about users

            - The `finger` command displays the '.plan' file of a specific user, or reports who is logged into a specific machine

            - Syntax for `finger`: finger [options] [user]@[hostname]
                finger
                    - Displays information about all users
                        - Information includes 'login' 'name', 'time', 'office number', and 'home phone number'
                finger username
                    - Displays information about [username]
                        - Information includes: 'login', 'home directory', 'shell', 'name', 'logged in time', etc.

            - Some flags for `finger`:
                finger -l
                    - Forces a long output format
                finger -s
                    - Forces a short output format
                finger -m [name]
                    - Matches username only, not first or last name

        8.3.3 - Remote commands

            - Unix machines on the same local area network can be connected to each other
                - Commands such as `rlogin`, `rsh`, and `rcp` allow users to execute common operations on another machine

            - The `rlogin` command allows remote login access to another host in the local network
                - `rlogin` passes information about the local environment to the remote host
                    - i.e. The value of the $TERM environment variable

            - The `rsh` command provides the ability to invoke a Unix shell on a remote host in the local network

            - The `rcp` allows the ability to copy files from the local host to a remote host in the local network
                - `rcp` does not prompt for passwords, so you must have permission, as the selected user, to execute remote commands on the remote machine

            - The syntax(es) for these commands are:
                rlogin [ -l username] remote_host
                rsh [ -l username] remote_host [command]
                rcp [[user1]@host1:]original_filename [[user2]@host2:]new_filename

            - The `-l [username]` flag allows you to connect as the user [username] on the remote machine
                - Only works for `rlogin` and `rsh`

            - The Secure SHell (SSH) versions of `rcp`, `rsh`, and `rlogin` are much better in terms of functionality and security 
                - It is reccommended that `ssh` be used instead of `rsh`

CHAPTER 9 - Shell Programming

    9.1 - Shell Scripts

        - Shell programs are created through scripts containing a series of shell commands
            - The first line of the script should start with '#!'
                - This tells the kernel that the script is directly executable
                - '#!' means 'shebang'
            - The '#!' symbol is immediately followed with the name of the shell to execute
                - The full path name is required
                    - For example: 
                        #!/bin/bash
                        #!/bin/sh
                        #!/bin/zsh
                        #!/bin/ksh
                        #!/bin/csh -f
                            - The `-f` flag tells the shell not to read your '.cshrc' file
            - Normally, the '#' symbol indicates a comment, however, the '#!' is a special case since it is the first few characters of the file
            - The shell script can be turned into an executable with `chmod`
                - For example: 
                    chmod +x shell_script
                    chmod +x script_name
                    chmod +x my_script_name

    9.2 - Setting Parameter Values

        - Parameter values are assigned as:
            Bourne Shell:
                param=value
            C Shell: 
                set param = value
            - Note: 'value' is any valid string
                - It can be enclosed within single or double quotes; to allow spaces
                - When 'value' is enclosed in backticks (i.e. `value`), then the string is first evaluated by the shell and the result is substituted
                    - This is often used to run a command
                        - For example:
                            day=`date +%a`
                            name=`whoami`
            - After parameter values have been assigned, they can be accessed using the following notation:
                $param
                  OR
                ${param}

    9.3 - Quoting

        - Quotes are used to control the way the shell interprets any parameters or variables within the string
            - Single ( ' ) or double ( " ) quotes are used to enclose strings
                - Double quotes allow variable substitution
                - Single quotes prevent variable substitution
            - A backslash ( / ) before a character is used to escape it
                - It instructs the shell to take it literally, without assigning any special meaning to it
                    - i.e. money="\$100.12"
            - Examples: (Assume that a variable 'var' has been assigned a string value 'bat' to it)
                echo $var'man'
                echo $var"man"
                echo ${var}man

    9.4 - Variables

        - When the shell starts, it automatically sets a number of variables
            - These variables allow you to reference arguments on the command line
                - The following table summarizes shell variables

        |-------------|-----------------------------------------------------------|----|-----|
        | VARIABLE    | USAGE                                                     | SH | CSH |
        |-------------|-----------------------------------------------------------|----|-----|
        | $#          | Number of arguments on the command line                   | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $-          | Options supplied to the shell                             | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $?          | Exit value of the last command executed                   | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $$          | Process number of the current process                     | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $!          | Process number of the last command done in background     | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $n          | Argument on the command line, where n is from 1 to 9      | Y  |  N  |
        |             |   It is read left to right                                |    |     |
        |-------------|-----------------------------------------------------------|----|-----|
        | $0          | The name of the current shell or program                  | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $*          | All arguments on the command line ("$1 $2 ... $9")        | Y  |  N  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $@          | All arguments on the command line, each separately quoted | Y  |  N  |
        |             |   (i.e. "$1" "$2" ... "$9")                               |    |     |
        |-------------|-----------------------------------------------------------|----|-----|
        | $arg[n]     | Selects the nth word from the input list                  | N  |  Y  |
        |-------------|-----------------------------------------------------------|----|-----|
        | ${arg[n]}   | Same as above                                             | N  |  Y  |
        |-------------|-----------------------------------------------------------|----|-----|
        | $#argv      | Report the nmber of words in the input list               | N  |  Y  |
        |-------------|-----------------------------------------------------------|----|-----|

        - For example:
            echo $?
            echo $0
            echo $$
        - The '$n', '$@', '$-', etc. are very useful in scripts. This is because they can retrieve arguments
            - For instance, if you ran a script:
                ./my_script arg1 arg2 arg3
            - The arguments can be retrieved with:
                echo $1
                    - Prints: arg1
                echo $2
                    - Prints: arg2
                echo $3
                    - Prints: arg3

    9.5 - Parameter Substitution

        - Parameters can be abstractly referenced
            - Values can be substituted for parameters based on conditional settings using the operators defined below
                - For example:
                    $parameter
                        - Substitute the value of `parameter` for this string
                    ${parameter}
                        - Same as above
                    $parameter=
                        - Sets `parameter` to null
                    ${parameter-default}
                        - If `parameter` is not set, then use `default` as the value
                            - The `parameter` is NOT reset
                    ${parameter=default}
                        - If `parameter` is not set, then set it to `default` and use the new value
                    ${parameter+newval}
                        - If `parameter` is set, then use `newval`, otherwise use nothing here
                            - The `parameter` is NOT reset
                    ${parameter?message}
                        - If `parameter` is not set, then display `message`
                            - If `parameter` is set, then use its current value
                    - Note: There are no spaces in the above operators
                        - If a colon ( : ) is inserted before the '-', '=', '+', or '?', then a test is performed to see if the parameter has a non-null setting. 
                            - For example:
                                ${parameter:=default}
                                ${parameter:+newval}
        - The C shell has a few additional ways of substituting parameters:
            $list[n]
                - Selects the nth word from `list`
            ${list[n]}
                - Same as above
            $#list
                - Prints the number of words in `list`
            $?parameter
                - Return 1 if parameter is set, 0 otherwise
            ${?parameter}
                - Same as above
            $<
                - Read a line from 'stdin'

    9.6 - Here Document

        - A 'here document' is a form of quoting that allows shell variables to be substituted
            - It's a special form of redirection that starts with <<WORD and ends with WORD as the only contents of a line
                - In bourne shell, you can prevent shell substitution by escaping WORD by putting a backslash infront of it 
                    - (i.e. <<\WORD)
        - For example:
            $ cat <<EOF > doc.txt
            Type whatever 
            you want
            right here
            and it gets
            accepted
            EOF
            $ # EOF ends the input 

    9.7 - Interactive Input

        9.7.1 - Sh

            - 'SH' uses the built in command, `read`, to read in a line
                - For example:
                    read param
                        - This prompts the user for input and stores it into 'param'
            - Using `read`:
                $ read param         # Prompts for user input
                Something
                $ echo $param        # Echoes whatever the user input-ted
                Something

        9.7.2 - Csh

            - 'CSH' uses the '$<' symbol to read a line from 'stdin'
                - For example:
                    set param = $<
                        - Note: The spaces around the '=' are important
            - Using '$<':
                $ set param = $<     # Prompts for user input
                input_here
                $ echo $param        # Echoes whatever the user input-ted
                input_here

    9.8 - Functions

        - The Bourne shell has functions
            - Functions allow flexibility and automation
            - A function has the form:
                fcn() { command; }
                    - Note, the space after the first curly brace ( { ) and semi-colon ( ; ) is required
                - For example:
                    ls() { /bin/ls -sbF "$@";}
                        - Redirects `ls` so that the flags `-sbF` are always applied
                    ll() { ls -al "$@";}
                        - Adds the flags `-al` to the previous function

    9.9 - Control Commands

        9.9.1 - Conditional if

            - The 'conditional if' is available in 'sh' and 'csh', but each shell has a different syntax

            9.9.1.1 - Sh

                - The syntax for the 'conditional if' in 'sh' is:

                    if [ condition_1 ]
                    then
                    run these commands if condition_1 is true
                    elif [ condition_2 ]
                    then
                    run these commands if condition_2 is true
                    else
                    run this if neither conditions are true
                    fi

                    - Note:
                        - The conditions are tested with the `test` command or the `[]` command
                        - There must be a space after the first opening square bracket ( [ ), and another space after the enclosing square bracket ( ] )
                        - The 'if' and 'then' must be separated; either with a <newline> or a semi-colon ( ; )
                        - The 'fi' indicates the end of the conditional and must be included

                - A sample 'sh' script demonstrating 'conditional if':

                    # This script: 
                    #  Prints 'No input' if no arguments are supplied
                    #  If one argument is supplied, it prints the first argument
                    #  If two or more arguments are supplied, it prints the second argument
                    #!/bin/sh
                    if [ $# -ge 2 ]
                    then
                    echo $2
                    elif [ $# -eq 1 ]; then
                    echo $1
                    else
                    echo No input
                    fi

            9.9.1.2 - Csh

                - The syntax for the 'conditional if' in 'csh' is:

                    if ( condition_1 ) then
                    run commands if condition_1 is true
                    else if ( condition_2 ) then
                    run commands if condition_2 is true
                    else 
                    run this if neither conditions are true
                    endif

                    - Note: 
                        - The 'if' and 'then' must be on the same line
                        - There must be a space after the first round bracket, and before the second enclosing round bracket
                        - 'endif' indicates the end of the conditional

                - A sample 'csh' script 'conditional if':

                    # This script:
                    #  Prints 'No input' if no arguments are supplied
                    #  If one argument is given, it prints first argument
                    #  If two or more arguments are given, it prints the second one
                    #!/bin/csh -f
                    if ( $#argv >= 2 ) then
                    echo $2
                    else if ( $#argv == 1 ) then
                    echo $1
                    else
                    echo No input
                    endif

        9.9.2 - Conditional switch and case

            - To choose between a set of string values for a paramter:
                - Use 'case' in Bourne shell
                - Use 'switch' in C shell

            9.9.2.1 - Sh

                - The syntax for 'case' is:

                    case parameter in
                    pattern_1|pattern_1A) command list_1;;
                    pattern_2) command list_2
                    command list2a;;
                    pattern_3) command list_3;;
                    *) ;;
                    esac

                    - Note: 
                        - You can use any valid filename meta-characters within the patterns to be matched
                        - The ';;' ends each choice and can be on the same line or a newline
                        - Additional alternative patterns to be selected for a case are separated by the vertical bar ( | )
                            - Just like the first pattern line in the example above
                                - i.e. pattern_1|pattern_1A)
                        - The wildcard symbols ( ? ) indicates any one character
                        - The wildcard ( * ) matches any number of characters
                        - 'esac' marks the end of the 'case' statement

                - A sample 'sh' script demonstrating 'case':

                    #!/bin/sh
                    case $1 in
                    aa|ab) echo A ;;
                    b?) echo "B \c"
                    echo $1;;
                    c*) echo C;;
                    *) echo D;;
                    esac

                    - Note:
                        - The first pattern matches 'aa' OR 'ab'
                        - The second pattern matches 'b?'
                            - i.e. 'be', 'bb', 'bc', etc.
                        - The third pattern matchines 'c*'
                            - i.e. 'coooom', 'cow', 'ccc', etc.
                        - The last pattern matches everything
                            - i.e. 'ice', 'vanilla', 'z', etc.

            9.9.2.2 - Csh

                - The syntax for 'switch' is:

                    switch (parameter)
                    case pattern_1:
                    command list_1
                    [breaksw]
                    case pattern_2:
                    command list_2
                    [breaksw]
                    default:
                    command list for default behavior
                    [breaksw]
                    endsw

                    - Note:
                        - 'breaksw' is optional and can be used to break out of the 'switch' after a match is found
                        - 'switch' does not accept the vertical bar ( | ) in the pattern list
                            - Alternatively, you can have several 'case' statements to achieve the same effect
                        - 'endsw' marks the end of the 'switch' statement

                - A sample 'csh' script demonstrating 'switch':
                    - The following script has the same behaviour as the 'sh' script above

                    #!/bin/csh -f
                    switch ($1)
                    case aa:
                    case ab:
                    echo A
                    breaksw
                    case b?:
                    echo -n "B "
                    echo $1
                    breaksw
                    case c*:
                    echo C
                    breaksw
                    default:
                    echo D
                    endsw

        9.9.3 - for and foreach

            - The `for` and `foreach` commands are used to loop through a list of string values
                - `for` is used in Bourne shell
                - `foreach` is for C Shell

            9.9.3.1 - Sh

                - The syntax for 'for' is:

                    for variable [ in list_of_values ]
                    do
                    command list
                    done

                    - Note:
                        - There needs to be a space after the first square bracket and another space before the second enclosing square bracket
                            - i.e. [ in list_of_values ]
                        - 'list_of_values' is optional, and if nothing is specified, then '$@' is assumed
                        - Each value in 'list_of_values' is sequentially substituted for 'variable' until the list is emptied
                        - 'done' marks the end of the 'for' statement

                - A sample 'sh' script demonstrating 'for':

                    #!/bin/sh
                    for file in *.old
                    do
                    newf=`basename $file .old`
                    cp $file $newf.new
                    done

                    - Note:
                        - This script copies all files ending in '.old' and makes similar files ending in '.new'
                            - The `basename` command is used to extract the base part of the name; no extension
                                - i.e. basename essay.txt == essay

            9.9.3.2 - Csh

                - The syntax for 'foreach' is:

                    foreach variable ( list_of_values )
                    command list
                    end

                    - Note: 
                        - There needs to be a space after the first round bracket and before the second enclosing bracket
                            - i.e. ( list_of_values )
                        - 'end' marks the end of the 'foreach' statement

                - A sample 'csh' script demonstrating 'foreach':

                    #!/bin/csh -f
                    foreach file ( *.old )
                    set newf = `basename $file .old`
                    cp $file $newf.new
                    end

                - Note:
                    - This script is functionally equivalent to the 'sh' script above

        9.9.4 - while

            - The 'while' command executes a series of commands, or command, as long as the initial condition is true

            9.9.4.1 - Sh

                - The syntax for 'while' is: 

                    while [ condition ]
                    do
                    command list
                    [break]
                    [continue]
                    done

                    - Note:
                        - There must be a space after the first square bracket, and before the second enclosing square bracket
                            - i.e. while [ condition ]
                        - 'break' is optional and is used to break out of the loop
                        - 'continue' is optional and is used to skip a condition
                        - 'done' marks the end of the 'while' loop

                    - A sample 'sh' script demonstrating 'while':

                        #!/bin/sh
                        while [ $# -gt 0 ]
                        do
                        echo $1
                        shift
                        done

                        - Note: 
                            - This script takes the list of arguments, echoes the first one, then shifts the list to the left, losing the first argument. It loops through until it has shifted all the arguments off the list

            9.9.4.2 - Csh

                - The syntax for 'while' is:

                    while ( condition )
                    command list
                    [break]
                    [continue]
                    end

                    - Note: 
                        - There needs to be a space after the first round bracket and before the second enclosing round bracket
                            - i.e. while ( condition )
                        - 'break' is optional and is used to break out of the loop
                        - 'continue' is optional and is used to skip a condition
                        - 'done' marks the end of the 'while' loop
                        - If you always want the 'condition' to be true, specify 1
                            - i.e. while ( 1 )...

                - A sample 'csh' script demonstrating 'while':

                    #!/bin/csh -f
                    while ( $#argv != 0 )
                    echo $argv[1]
                    shift
                    end

                    - Note: 
                        - This script is functionally equivalent to the 'sh' script above

        9.9.5 - until

            - This looping feature is only available in Bourne Shell

            - The syntax for 'until' is:

                until [ condition ] 
                do
                command list while condition is false
                done

                - Note:
                    - The condition is tested at the start of each loop and the loop is terminated when the condition is true
                    - As usual, there needs to be a space after the first square bracket, and before the second square bracket
                        - i.e. until [ condition ] 
                    - 'done' marks the end of the loop

            - A sample 'sh' script demonstrating 'until':

                #!/bin/sh
                until [ $# -le 0 ]
                do
                echo $1
                shift
                done

                - Note:
                    - This script checks the argument list to see if it is less than or equal to 0
                        - If false: Print first argument to 'stdout', shift the argument list and remove the first argument. Repeat loop
                        - If true: terminate
                    - Remember: The 'until' loop is looking for a false condition

            - Both 'until' and 'while' loops are only executed if the condition is satisfied
                - The condition is evaluated before the commands are executed

        9.9.6 - test

            - Conditional statements are evaluated for 'true' or 'false' values
                - This is done with 'test', or its equivalent, the [] operators
                    - Note: Recall from above that 'conditions' are placed in [square] [brackets]
                - If the condition evaluates to true, a zero exit status is set
                    - ZERO == TRUE
                - If the condition evaluates to false, a non-zero exit status is set
                    - Any non-zero number is FALSE
                - If there are no arguments, a non-zero exit status is set
            - The operators used by the Bourne shell conditional statements are below:
                - For 'filenames' the options to 'test' are given with the syntax:
                    -option filename
                - The options available for the 'test' operator for 'files' include:
                    -r :: true if it exists and is readable
                    -w :: true if it exists and is writable
                    -x :: true if it exists and is executable
                    -f :: true if it exists and is a regular file
                          OR for 'csh', exists and is not a directory
                    -d :: true if it exists and is a directory
                    -h :: true if it exists and is a symbolic link 
                    -L :: Same as above ( -h )
                    -c :: true if it exists and is a character special file
                          (i.e. The special device is accessed one character at a time)
                    -b :: true if it exists and is a block special file
                          (i.e. The device is accessed in blocks of data)
                    -p :: true if it exists and is a named pipe (fifo)
                    -u :: true if it exists and is setuid
                          (i.e. Has the set-user-id bit set, s or S in the third bit)
                    -g :: true if it exists and is setgid
                          (i.e. Has the set-group-id bit set, s or S in the sixth bit)
                    -k :: true if it exists and sticky bit is set (a 't' in bit 9)
                    -s :: true if it exists and is greater than zero in size
                - The test for 'file_descriptors' is:
                    -t [file_descriptor] true if the open file descriptor (default is 1, stdin) is associated with a terminal
                - The tests for 'strings' are:
                    -z string
                        true if the string length is zero
                    -n string
                        true if the string length is non-zero
                    string1 = string2
                        true if string1 is identical to string2
                    string1 != string2
                        true if string1 is non identical to string2
                    string
                        true if string is not NULL
                - The are integer comparisons:
                    n1 -eq n2 :: true if integers n1 and n2 are equal
                    n1 -ne n2 :: true if integers n1 and n2 are not equal
                    n1 -gt n2 :: true if integer n1 is greater than integer n2
                    n1 -ge n2 :: true if integer n1 is greater than or equal to integer n2
                    n1 -lt n2 :: true if integer n1 is less than integer n2
                    n1 -le n2 :: true if integer n1 is less than or equal to integer n2
                        - Note: 'n1' and 'n2' are integers; decimal values not permitted
                - The following logical operators are also available:
                    !  --> negation (unary)
                    -a --> and (binary)
                    -o --> or (binary)
                - () expressions within the () are grouped together
                    - You may need to quote the () to prevent the shell from interpreting them

        9.9.7 - C Shell Logical and Relational Operators

            - The C shell has its own set of built in logical and relational expression operators
                - In descending order of precedence they are summarized in the table below:

            OPERATOR    | DEFINITION
            ------------|------------------------------------------------------
            (...)       | Group expressions with ()
            ------------|------------------------------------------------------
            ~           | Inversion / Complement
            ------------|------------------------------------------------------
            !           | Logical negation
            ------------|------------------------------------------------------
            *           | Multiply
            ------------|------------------------------------------------------
            /           | Divide
            ------------|------------------------------------------------------
            %           | Modulus
            ------------|------------------------------------------------------
            +           | Addition
            ------------|------------------------------------------------------
            -           | Subtraction
            ------------|------------------------------------------------------
            <<          | Bitwise shift left
            ------------|------------------------------------------------------
            >>          | Bitwise shift right
            ------------|------------------------------------------------------
            <=          | Less than or equal to
            ------------|------------------------------------------------------
            >=          | Greater than or equal to
            ------------|------------------------------------------------------
            <           | Less than 
            ------------|------------------------------------------------------
            >           | Greater than
            ------------|------------------------------------------------------
            ==          | Equal
            ------------|------------------------------------------------------
            !=          | Not equal
            ------------|------------------------------------------------------
            =~          | Match a string 
            ------------|------------------------------------------------------
            !~          | Don't match the string
            ------------|------------------------------------------------------
            &           | bitwise AND
            ------------|------------------------------------------------------
            ^           | bitwise XOR (aka exclusive OR)
            ------------|------------------------------------------------------
            |           | bitwise OR
            ------------|------------------------------------------------------
            &&          | logical AND 
            ------------|------------------------------------------------------
            ||          | logical OR
            ------------|------------------------------------------------------
            {command}   | true (1) if command terminates with a zero
                        |   exit status, false(0) otherwise
            ------------|------------------------------------------------------

            - The C shell also allows file type and permission inquiries with the following operators:
                -r :: return true (1) if it exists and is readable, otherwise return false (0)
                -w :: true if it exists and is writable
                -x :: true if it exists and is executable
                -f :: true if it exists and is a regular file 
                      OR for 'csh', exists and is not a directory
                -d :: true if it exists and is a directory
                -e :: true if the file exists
                -o :: true if the user owns the file
                -z :: true if the file has zero length (aka Is Empty)

CHAPTER 10 - Editors

    - There are numerous text processing utilities available with Unix 
        (i.e. `ed`, `ex`, `sed`, `awk`, `grep`, etc.)
    
    - The standard visual/fullscreen editor on Unix is `vi`
        - `vi` is a super-set of `ed` and `ex` capabilities
        - Vi is a modal editor
            - This means that it has specific modes that allow text insertion, deletion, and command entering
                - To exit insert mode, hit the <ESC> key. This brings you back to command mode
        - You can switch between fullscreen mode and line mode
            - When in Vi, type 'Q' to go into `ex` mode
                - When in `ex` mode, type 'vi' to return to fullscreen mode
        - The read-only mode of `vi` can be accessed by typing 'view'

    - Another popular editor is `emacs`
        - `emacs` stands for editing macros
        - `emacs` does not (usually) come with Unix operating systems
            - It is distributed by the Free Software Foundation (FSF)
        - Arguably, `emacs` is the most powerful editor availabe for Unix
            - The software package is very large and is a heavy user of hardware resources

    - Both `vi` and `emacs` allow you to create start-up files that you can populate with macros to control settings and functions in the editors

    10.1 - Configuring Your vi Session

        - To configure the 'Vi' environment, type ':set' during a 'Vi' editing session
            - Alternatively, frequently used options can be set automatically when `vi` is invoked, by use of the '.exrc' file
                - The '.exrc' file can also contain macros to map keystrokes into functions using the `map` function
        - The following list contains some configurable options available in 'Vi':
            :set all 
                - Display all option settings
            :set ignorecase 
                - Ignore the case of a character in a search
            :set list 
                - Display tabs and carriage returns
            :set nolist 
                - Turn off list option
            :set number 
                - Display line numbers
            :set nonumber 
                - Turn off line numbers
            :set showmode 
                - Display indication that insert mode is on
            :set noshowmode 
                - Turn off showmode option
            :set wrapmargin=n 
                - Turn on word-wrap n spaces from the right margin
            :set wrapmargin=0 
                - Turn off wrapmargin option
            :set warn 
                - Display "No write since last change"
            :set nowarn 
                - Turn off "write" warning

    10.2 - Configuring Your emacs Session

        - Configuring the `emacs` environment amounts to making calls to LISP functions
            - Settings can be specified from the minibuffer, or command line, during an `emacs` session
                - Alternatively, frequently used settings can be automatically invoked by the use of a '.emacs' file
            - The following list is an example of common `emacs` configuration:
                M-x what-line 
                    - What line is the cursor on?
                M-x auto-fill-mode 
                    - Turn on word-wrap
                M-x auto-fill-mode 
                    - Turn off word-wrap
                M-x set-variable<return> fill-column<return> 
                    - Set line-length to 45 45 characters
                M-x set-variable<return> auto-save-interval<return> 
                    - Save the file automatically after every 300 300 keystrokes
                M-x goto-line<return>16 
                    - Move the cursor to line 16
                M-x help-for-help 
                    - Invoke emacs help when C-h has been bound to the backspace key

                - Note: 'M' refers to the 'Meta' key, which is the <ESC> key
                    - i.e. So M-x means: Hit 'ESC' and then 'X'

    10.3 - vi Quick Reference Guide

        - All commands in `vi` are preceded by pressing the <ESC> key
            - The <ESC> key needs to be used each time a different command is entered
                - `vi` is case sensitive
        - The following is a quick reference guide for 'Vi':

            - Cursor Movement Commands: 
            [Note: (n) indicates a number, and is optional]
            (n) h :: Move left (n) spaces
            (n) j :: Move down (n) spaces
            (n) k :: Move up (n) spaces
            (n) l :: Move right (n) spaces
            [The arrow keys usually work also]
            ^F :: Move forward one screen
            ^B :: Move back one screen
            ^D :: Move down one screen
            ^U :: Move up half a screen
            [Note: ^ means CTRL (The 'control' key); case does not matter]
            H :: Go to beginning of top line of screen  
            M :: Go to beginning of middle line of screen
            L :: Go to beginning of last line of screen
            G :: Go to beginning of last line of file
            (n) G :: Move to beginning of line (n)
            0 :: Beginning of line (Zero)
            $ :: End of line
            (n)w :: Forward (n) word(s)
            (n)b :: Back (n) word(s)
            e :: End of word

            - Inserting Text:
            [Note: Case does matter]
            i :: Insert text before the cursor
            a :: Append text after the cursor (does not overwrite other text)
            I :: Insert text at the beginning of the line
            A :: Append text to the end of the line
            r :: Replace the character under the cursor with the next character typed
            R :: Overwrite characters until the end of the line (or until escape is 
                   pressed to change command)
            o :: Open new line after the current line to type text (alpha o)
            O :: Open new line before the current line to type text (alpha O)

            - Deleting Text:
            [Note: Case matters]
            dd    :: Deletes current line
            (n)dd :: Deletes (n) line(s)
            (n)dw :: Deletes (n) word(s)
            D     :: Deletes from cursor to end of line
            x     :: Deletes current character
            (n)x  :: Deletes (n) character(s)
            X     :: Deletes previous character

            - Change Commands:
            [Note: Case matters]
            (n)cc :: Changes (n) characters on line(s) until end of the line, 
                       or until escape is pressed
            cw    :: Changes characters of word until end of the word or 
                       until escape is pressed
            (n)cw :: Changes characters of the next (n) words
            c$    :: Changes text to the end of the line
            ct(x) :: Changes text to the letter (x)
            C     :: Changes remaining text on the current line, 
                       until stopped by escape key
            ~     :: Changes the case of the current character
            J     :: Joins the current line and the next line
            u     :: Undo the last command just done on this line
            .     :: Repeats last change
            s     :: Substitutes text for current character
            S     :: Substitutes text for current line
            :s    :: Substitutes new word(s) for old
                       :<line nos effected> s/old/new/g
            &     :: Repeats last substitution (:s) command.
            (n)yy :: Yanks (n) lines to buffer
            y(n)w :: Yanks (n) words to buffer
            p     :: Puts yanked or deleted text after cursor
            P     :: Puts yanked or deleted text before cursor

            - File Manipulation:
            [Note: Case is important]
            :w (file)    :: Writes changes to 'file' (default is current file)
            :wq          :: Writes changes to current file and quits edit session
            :w! (file)   :: Overwrites 'file' (default is current file)
            :q           :: Quits edit session w/no changes made
            :q!          :: Quits edit session and discards changes
            :n           :: Edits next file in argument list
            :f (name)    :: Changes name of current file to (name)
            :r (file)    :: Reads contents of 'file' into current edit at the 
                              current cursor position (Insert a file)
            :!(command)  :: Shell escape
            :r!(command) :: Inserts result of shell command at cursor position
            ZZ           :: Write changes to current file and exit

    10.4 - emacs Quick Reference Guide

        - Emacs commands are executed by either:
            - Holding down the control key (indicated by C-)
              OR
            - First hitting the escape key (indicated by M-)

        - Essential Commands:
        C-h     :: Help
        C-x u   :: Undo
        C-x C-g :: Get out of current operation or command
        C-x C-s :: Save the file
        C-x C-c :: Close Emacs

        - Cursor Movement Commands: 
        C-f :: Forward one character
        C-b :: Back one character
        C-p :: Previous line
        C-n :: Next line
        C-a :: Beginning of line
        C-e :: End of line
        C-l :: Center current line on screen
        C-v :: Scroll forward
        M-v :: Scroll backward
        M-f :: Forward one word
        M-b :: Back one word
        M-a :: Beginning of sentence
        M-e :: End of sentence
        M-[ :: Beginning of paragraph
        M-] :: End of paragraph
        M-< :: Beginning of buffer
        M-> :: End of buffer

        - Other Important Functions:
        M-(n) :: Repeat the next command (n) times
        C-d   :: Delete a character
        M-d   :: Delete a word
        C-k   :: Kill line
        M-k   :: Kill sentence
        C-s   :: Search forward
        C-r   :: Search in reverse
        M-%   :: Query replace
        M-c   :: Capitalize word
        M-u   :: Uppercase word
        M-l   :: Lowercase word
        C-t   :: Transpose characters
        M-t   :: Transpose words
        C-@   :: Mark beginning of region
        C-w   :: Cut--wipe out everything from mark to point
        C-y   :: Paste--yank deleted text into current location
        M-q   :: Reformat paragraph
        M-g   :: Reformat each paragraph in region
        M-x auto-fill-mode
            - Turn on word wrap
        M-x set-variable <return> fill-column <return> 45
            - Set length of lines to 45 characters
        M-x goto-line <return> 16   
            - Move cursor to line 16
        M-w     :: Copy region marked
        C-x C-f :: Find file and read it
        C-x C-v :: Find and read alternate file
        C-x i   :: Insert file at cursor position
        C-x C-s :: Save file
        C-x C-c :: Exit emacs, and be prompted to save
        C-x C-w :: Write buffer to a different file

CHAPTER 11 - Unix Command Summary

    11.1 - Unix Commands

        - The table below summarizes frequently used commands on a Unix system
            - The term 'file' could be an actual file name, or a list of file names, or input/output could be redirected to or from the command

        COMMAND / SYNTAX               | DEFINITION
        -------------------------------|--------------------------------------
        awk/nawk [options]             | File scan for patterns in a file and
                                       | process the results
        -------------------------------|--------------------------------------
        cat [options] [file]           | Concatenate (list) a file
        -------------------------------|--------------------------------------
        cd [directory]                 | Change directory
        -------------------------------|--------------------------------------
        chgrp [options] [group] [file] | Change the group of the file
        -------------------------------|--------------------------------------
        chmod [options] [file]         | Change file or directory access 
                                       | permissions
        -------------------------------|--------------------------------------
        chown [options] [owner] [file] | Change the ownership of a file; can
                                       | only be done by the superuser
        -------------------------------|--------------------------------------
        chsh (passwd -e/-s) [username] | Change the user's login shell (often
        [login_shell]                  | only by the superuser)
        -------------------------------|--------------------------------------
        cmp [options] [file1] [file2]  | Compare two files and list where 
                                       | differences occur (text or binary 
                                       | files)
        -------------------------------|--------------------------------------
        compress [options] [file]      | Compress file and save it as 'file.Z'
        -------------------------------|--------------------------------------
        cp [options] [file1] [file2]   | Copy file1 into file2; file2 should
                                       | not already exist. This command 
                                       | creates or overwrites file2
        -------------------------------|--------------------------------------
        cut (options) [file(s)]        | Cut specified field(s)/character(s) 
                                       | from lines in file(s)
        -------------------------------|--------------------------------------
        date [options]                 | Report the current date and time
        -------------------------------|--------------------------------------
        dd [if=infile] [of=outfile]    | Copy a file, converting between ASCII 
        [operand=value]                | and EBCDIC or swapping byte order, 
                                       | as specified
        -------------------------------|--------------------------------------
        diff [options] [file1] [file2] | Compare the two files and display 
                                       | the differences (text files only)
        -------------------------------|--------------------------------------
        df [options] [resource]        | Report the summary of disk blocks and 
                                       | inodes free and in use
        -------------------------------|--------------------------------------
        du [options] [directory/file]  | Report amount of disk space in use
        -------------------------------|--------------------------------------
        echo [string_of_text]          | echo 'string_of_text' to 'stdout'
        -------------------------------|--------------------------------------
        ed [options] [file]            | The commands `ed` and `ex are: 
        ex [options] [file]            | Unix line editors
        -------------------------------|--------------------------------------
        emacs [options] [file]         | Full-screen editor
        -------------------------------|--------------------------------------
        expr [arguments]               | Evaluate the arguments. Used to do 
                                       | arithmetic, etc. in the shell.
        -------------------------------|--------------------------------------
        file [options] [file]          | Classify the file type
        -------------------------------|--------------------------------------
        find [directory] [options]     | Find files matching a type or pattern
        [actions]                      | 
        -------------------------------|--------------------------------------
        finger [options]               | Report information about users on
        [user]@[hostname]              | local and remote machines
        -------------------------------|--------------------------------------
        ftp [options] [host]           | Transfer file(s) using file transfer 
                                       | protocol
        -------------------------------|--------------------------------------
        grep [options] 'search_string' | The `grep` commands search the 
        [argument]                     | [argument] (i.e. Text file) for
                                       | all occurences of 'search_string'
        -------------------------------| and lists them
        egrep [options] 'search_string'|
        [argument]                     | `egrep` is extended grep
        -------------------------------|
        fgrep [options] 'search_string'| `fgrep` is fixed grep
        [argument]                     |
        -------------------------------|--------------------------------------
        gzip [options] [file]          | Compress or uncompress a file.
        gunzip [options] [file]        | Compressed files are stored with
                                       | a '.gz' ending
        -------------------------------|--------------------------------------
        zcat [options] [file]          | In addition to compress/uncompress, 
                                       | 'zcat' can also display the contents 
                                       | of a compressed file
        -------------------------------|--------------------------------------
        head -n [file]                 | Print the first 'n' number of lines
                                       | of a file, starting at the top
        -------------------------------|--------------------------------------
        hostname                       | Display or set (super-user only) the 
                                       | name of the current machine
        -------------------------------|--------------------------------------
        kill [options] [-SIGNAL]       | Send a signal to the process with the 
        [pid#] [%job]                  | process id number (pid#) or job  
                                       | control number (%n). The default
                                       | signal kills the process
        -------------------------------|--------------------------------------
        ln [options] [source_file]     | Link the [source_file] to the target
        [target]                       | 
        -------------------------------|--------------------------------------
        lpq [options]                  | The `lpq` and `lpstat` commands show 
        lpstat [options]               | the status of print jobs
        -------------------------------|--------------------------------------
        lpr [options] file             | The `lpr` and `lp` commands print to
        lp [options] file              | a defined printer
        -------------------------------|--------------------------------------
        lprm [options]                 | The commands `lprm` and `cancel` are 
        cancel [options]               | used to remove a print job from the
                                       | print queue
        -------------------------------|--------------------------------------
        ls [options] [directory/file]  | List directory contents or file 
                                       | permissions
        -------------------------------|--------------------------------------
        mail [options] [user]          | Simple email utility available on
        -------------------------------| Unix systems. Type a period as the
        mailx [options] [user]         | first character on a new line to
        -------------------------------| send a message out, and a question
        Mail [options] [user]          | mark for help
        -------------------------------|--------------------------------------
        man [options] [command]        | Show the manual page for a command
        -------------------------------|--------------------------------------
        mkdir [options] directory      | Make an empty directory
        -------------------------------|--------------------------------------
        more [options] file            | Page through a text file
        -------------------------------| `less` is like `more` but smarter
        less [options] file            | and contains more functions and
        -------------------------------| features
        pg [options] file              |
        -------------------------------|--------------------------------------
        mv [options] [file1] [file2]   | move 'file1' into 'file2'
        -------------------------------|--------------------------------------
        od [options] [file]            | Octal dump a binary file, in octal, 
                                       | ASCII, hex, decimal, or character mode
        -------------------------------|--------------------------------------
        passwd [options]               | Set or change your password
        -------------------------------|--------------------------------------
        paste [options] [file]         | Paste field(s) onto the lines in file
        -------------------------------|--------------------------------------
        pr [options] [file]            | Filter the file and print it on the 
                                       | terminal
        -------------------------------|--------------------------------------
        ps [options]                   | Show status of active processes
        -------------------------------|--------------------------------------
        pwd                            | Print working (current) directory
        -------------------------------|--------------------------------------
        rcp [options] [hostname]       | Remotely copy files from this machine 
                                       | to another machine
        -------------------------------|--------------------------------------
        rlogin [options] [hostname]    | Login remotely to another machine
        -------------------------------|--------------------------------------
        rm [options] [directory/file]  | Remove (delete) a file or directory
                                       | `rm -r` is used to delete a directory 
                                       | and its contents
        -------------------------------|--------------------------------------
        rmdir [options] directory      | Remove (delete) an empty directory
        -------------------------------|--------------------------------------
        rsh [options] [hostname]       | Remote shell to run on another machine
        -------------------------------|--------------------------------------
        script [file]                  | Saves everything that appears on the 
                                       | screen to 'file' until `exit` is 
                                       | executed
        -------------------------------|--------------------------------------
        sed [options] [file]           | Stream editor for editing files from 
                                       | a script or from the command line
        -------------------------------|--------------------------------------
        sort [options] [file]          | Sort the lines of 'file' according 
                                       | to the options chosen
        -------------------------------|--------------------------------------
        source file                    | Read commands from [file] and execute
        . file                         | them in the current shell
        -------------------------------|--------------------------------------
        strings [options] [file]       | Report any sequence of 4 or more 
                                       | printable characters ending in
                                       | <NEWLINE> or <NULL>. Usually used to 
                                       | search binary files for ASCII strings
        -------------------------------|--------------------------------------
        stty [options]                 | Set or display terminal control options
        -------------------------------|--------------------------------------
        tail [options] [file]          | Display the last few lines (or parts) 
                                       | of [file]
        -------------------------------|--------------------------------------
        tar [key][options] [file(s)]   | Tape archiver--refer to man pages for 
                                       | details on creating, listing, and 
                                       | retrieving from archive files. Tar 
                                       | files can be stored on tape or disk
        -------------------------------|--------------------------------------
        tee [options] [file]           | Copy 'stdout' to one or more files
        -------------------------------|--------------------------------------
        telnet [host [port]]           | Communicate with another host using 
                                       | telnet protocol
        -------------------------------|--------------------------------------
        touch [options] [date] [file]  | Create an empty file, or update the 
                                       | access time of an existing file
        -------------------------------|--------------------------------------
        tr [options] [string1]         | Translate the characters in 'string1'
        [string2]                      | from 'stdin' into those in 'string2' 
                                       | in 'stdout'
        -------------------------------|--------------------------------------
        uncompress [file].Z            | Uncompress [file.Z] and save it as a 
                                       | file. The compressed file must end in
                                       | '.Z'
        -------------------------------|--------------------------------------
        uniq [options] [file]          | Remove repeated lines in a file
        -------------------------------|--------------------------------------
        uudecode [file]                | Decode [file], a uuencoded file,  
                                       | recreating the original file
        -------------------------------|--------------------------------------
        uuencode [file] [new_name]     | Encode binary file to 7-bit ASCII, 
                                       | useful when sending via email, to be 
                                       | decoded as new_name at destination
        -------------------------------|--------------------------------------
        vi [options] [file]            | Visual, full-screen editor
        -------------------------------|--------------------------------------
        wc [options] [file(s)]         | Display word (or character or line)
                                       | count for file(s)
        -------------------------------|--------------------------------------
        whereis [options] [command]    | Report the binary, source, and man 
                                       | page locations for [command]
        -------------------------------|--------------------------------------
        which [command]                | Reports the path to [command] or the 
                                       | shell alias in use
        -------------------------------|--------------------------------------
        who                            | Report who is logged in and what 
        w                              | processes are running
        -------------------------------|--------------------------------------
        zcat [file].Z                  | List the contents of the compressed
                                       | file, [file].Z. The file remains
                                       | compressed
        -------------------------------|--------------------------------------

CHAPTER 12 - A Short Unix Bibliography

    12.1 - Highly Recommended

        - UNIX for the Impatient
            - Paul W. Abrahams & Bruce R. Larson (Addison-Wesley Publishing Company, 1992, ISBN 0-201-55703-7) 
                - (A current favorite. Recommended in the CIS Department for Unix beginners)

        - UNIX in a Nutshell for BSD 4.3: A Desktop Quick Reference For Berkeley 
            - (O'Reilly & Associates, Inc., 1990, ISBN 0-937175-20-X)
                - (A handy reference for BSD)

        - UNIX in a Nutshell: A Desktop Quick Reference for System V & Solaris 2.0 
            - (O'Reilly & Associates, Inc., 1992, ISBN 0-56592-001-5)
                - (A handy reference for SysV and Solaris 2)

        - The UNIX Programming Environment
            - Brian W. Kernighan & Rob Pike (Prentice Hall, 1984)
                - (A classic. For serious folks)

        - When You Can't Find Your UNIX System Administrator
            - Linda Mui (O'Reilly & Associates, Inc., 1995, ISBN 1-56592-104-6)

        - UNIX Power Tools
            - Jerry Peek, Tim O'Reilly, and Mike Loukides 
                - (O'Reilly & Associates, 1993, ISBN 0-679-79073-X)
                    - (Includes a CDROM of useful software for various OSs)

    12.2 - Assorted Others

        - Understanding UNIX: A Conceptual Guide
            - James R. Groff & Paul N. Weinberg (Que Corporation, 1983)

        - Exploring the UNIX System
            - Stephen G. Kochan & Patrick H. Wood 
                - (SAMS, a division of Macmillan Computer Publishing, 1989, ISBN 0-8104-6268-0)

        - Learning GNU Emacs
            - Debra Cameron and Bill Rosenblatt 
                - (O'Reilly & Associates, 1992, ISBN 0-937175-84-6)

        - UNIX for Dummies
            - John R. Levine & Margaret Levine Young 
                - (IDG Books Worldwide, Inc., 1993, ISBN 0-878058-58-4)

        - A Practical Guide to UNIX System V
            - Mark G. Sobell 
                - (The Benjamin/Cummings Publishing Company, Inc., 1985, ISBN 0-80-530243-3)

        - UNIX Primer Plus
            - Mitchell Waite, Donald Martin, & Stephen Prata
                - (Howard W. Sams & Co., Inc., 1983, ISBN 0-672-30194-6)

        - An Introduction to Berkeley UNIX
            - Paul Wang 
                - (Wadsworth Publishing Company, 1988)

        - Unix Shell Programming 
            - Stephen G. Kochan & Patrick H. Wood 
                - (Hayden Book Co., 1990, ISBN 0-8104-6309-1)

        The Unix C Shell Field guide
            - Gail Anderson and Paul Anderson 
                - (Prentice Hall, 1986, ISBN 0-13-937468-X)

        A Student's Guide to UNIX
            - Harley Hahn
                - (McGraw-Hill, 1993, ISBN 0-07-025511-3)

        Tricks of the UNIX Masters
            - Russell G. Sage 
                - (Howard W. Sams & Co., Inc., 1987, ISBN 0-672-22449-6)
