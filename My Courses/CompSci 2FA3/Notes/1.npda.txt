presentation.1.npda.txt

Regular grammars and regular languages are recognized by DFAs, NFAs, and NFAs with e-transitions

Context free languages are generated by context free grammars and are recognized by non-deterministic pushdown automatas (NPDA). CFLs have two sublanguages. They are:
	1. Linear Languages: These are generated by linear grammars
	2. Deterministic Context Free Languages (DCFL): These are recognized by Deterministic Pushdown Automata (DPDA).

Context sensitive languages are generated by context sensitive grammars and are recognized by Linear Bounded Automata (LBA).

Recursively enumerable languages are produced by an actual computer program. These are generated by general grammars. 

A general grammar has no restriction on the production of the grammar.

Recursively enumerable languages are recognized by turing machines

Recursive languages are not generated by a particular kind of grammar but they are identified by Turing machines. 

NFAs
	An NFA has three components:
		1. Input Tape: A finite sequence of symbols 
		2. Memory: The memory is finite and is made up of states. The machine is in one of these states at any given time
		3. Program: A transition function. 

		Tape is read from left to right and nothing is written to the tape.

		The program is nondeterministic because the transition function offers possibly different alternatives and only one is taken each time.

NPDAs
	A nondeterministic push-down automaton has the following components:
		1. Input Tape: Is read left to right, and is read-only.
		2. Memory: Composed of two parts. A finite number of states and a stack.
			- The stack can be of any height. So it is infinite memory. Only the top of the stack can be looked at.
		3. Program: A transition relation. We can go from one configuration to another but we have possible choices. This is why it is a relation, and not a function.
	An NPDA is a tuple, M = (Q, Sigma, Gamma, Delta, s, Bottom, F)
		Q = Finite set of states
		Sigma = Finite set of symbols that compose the input alphabet
		Gamma = Finite set of symbols that compose the stack alphabet
		Delta = Transition relation
		s = Start State 
		Bottom = Initial stack
		F = Set of final states

	The stack symbols are the ones that are going to be placed on the stack 
	Delta is a binary relation where the first component is a triple 

	((p, a, A), (q, B1B2...Bk))
	p = State the machine is in
	a = Symbol on the tape
	A = Symbol on top of the stack
	q = new State
	B1B2...Bk = Set of finite stack symbols

	((p, e, A),(q, B1B2...Bk))
	When epsilon is the symbol on the tape, then the machine can pop A off the stack and push B1B2...Bk onto the stock and NOT move its read head, and enter state q

	A configuration of an NPDA M is a member of: Q x Sigma* x Gamma*
	This describes M's current state, unread input string, and stack contents

	M accepts x by final state if after reading ALL of x we are left with the empty string and we are in a state that is the final state.

	M can accept x by empty stack. After processing x, we are left with no more string to read and an empty stack.

		Either one can be choosed. The method is up to you and how comfortable you are. But if you can do 'Accepts by final state', then you can definitely do 'Accepts by empty stack'